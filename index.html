<!doctype html>
<html lang="ko">
  <head>
    <meta charset="UTF-8" />
    <meta name="viewport" content="width=device-width, initial-scale=1.0" />
    <title>2025 프론트엔드 트렌드</title>
    <script src="https://cdn.tailwindcss.com"></script>
    <script>
      tailwind.config = {
        darkMode: 'class',
        theme: {
          extend: {
            colors: {
              border: 'hsl(var(--border))',
              input: 'hsl(var(--input))',
              ring: 'hsl(var(--ring))',
              background: 'hsl(var(--background))',
              foreground: 'hsl(var(--foreground))',
              primary: {
                DEFAULT: 'hsl(var(--primary))',
                foreground: 'hsl(var(--primary-foreground))',
              },
              secondary: {
                DEFAULT: 'hsl(var(--secondary))',
                foreground: 'hsl(var(--secondary-foreground))',
              },
              destructive: {
                DEFAULT: 'hsl(var(--destructive))',
                foreground: 'hsl(var(--destructive-foreground))',
              },
              muted: {
                DEFAULT: 'hsl(var(--muted))',
                foreground: 'hsl(var(--muted-foreground))',
              },
              accent: {
                DEFAULT: 'hsl(var(--accent))',
                foreground: 'hsl(var(--accent-foreground))',
              },
              popover: {
                DEFAULT: 'hsl(var(--popover))',
                foreground: 'hsl(var(--popover-foreground))',
              },
              card: {
                DEFAULT: 'hsl(var(--card))',
                foreground: 'hsl(var(--card-foreground))',
              },
            },
            borderRadius: {
              lg: 'var(--radius)',
              md: 'calc(var(--radius) - 2px)',
              sm: 'calc(var(--radius) - 4px)',
            },
            fontFamily: {
              sans: ['Inter', 'ui-sans-serif', 'system-ui'],
            },
          },
        },
      };
    </script>
    <script src="https://cdn.jsdelivr.net/npm/chart.js"></script>
    <link rel="preconnect" href="https://fonts.googleapis.com" />
    <link
      rel="stylesheet"
      href="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/styles/atom-one-dark.min.css"
    />
    <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin />
    <link
      href="https://fonts.googleapis.com/css2?family=Inter:wght@300;400;500;600;700&display=swap"
      rel="stylesheet"
    />
    <!-- Chosen Palette: Calm Tech -->
    <!-- Application Structure Plan: A single-page application with a fixed sidebar for navigation and a dynamic main content area. This structure allows non-linear exploration, which is more effective for a technical audience (backend developers) who may want to jump directly to topics of interest like 'Collaboration Tips' or specific trends, rather than following a linear presentation. Interactions like tab switching, hover effects, and simple charts are used to make dense information more digestible. Top-level sections now act as headers with no direct content, guiding users to their detailed sub-sections for all information. -->
    <!-- Visualization & Content Choices: 
        - Intro: An interactive timeline (HTML/CSS) for evolution, plus a simple HTML/CSS diagram comparing old vs. new FE.
        - jQuery Era: A dedicated section explaining the impact of Google Maps and AJAX, with a sample image and code.
        - SPA Era: A dedicated section explaining the characteristics, pros, and cons of Single Page Applications, with a detailed timeline of AngularJS and React.
        - Frameworks: Card-based layout for comparison, HTML/CSS diagram for Server vs. Client Components, and a conceptual HTML/CSS diagram for Islands Architecture. Each framework also has a distinct unicode icon.
        - DX Tooling: HTML/CSS flow diagram for build tools, icons for test ecosystem, and a conceptual AI assistance icon.
        - State Management: A Bar Chart (Chart.js) for paradigm shift, and a simple HTML/CSS diagram for state minimization.
        - Fullstack FE: A conceptual HTML/CSS diagram illustrating the client-edge-server flow, emphasizing BFF role.
        - Role Expansion: Enhanced grid with more descriptive icons and brief explanations, now in its own sub-section.
        - Collaboration (new sub-sections):
            - API & Type: HTML/CSS diagram for type flow.
            - Communication: Interactive toggle diagram for CSR vs SSR.
            - Optimization: Icons for code splitting and caching.
        - Justification: These choices aim to translate the report's text-heavy content into a more scannable, visual, and interactive format, improving comprehension and retention for a busy, technical audience, while strictly adhering to the "NO SVG/Mermaid" constraint by using HTML/CSS for all diagrams.
    -->
    <!-- CONFIRMATION: NO SVG graphics used. NO Mermaid JS used. -->
    <style>
      :root {
        --background: 0 0% 100%;
        --foreground: 222.2 84% 4.9%;
        --card: 0 0% 100%;
        --card-foreground: 222.2 84% 4.9%;
        --popover: 0 0% 100%;
        --popover-foreground: 222.2 84% 4.9%;
        --primary: 222.2 47.4% 11.2%;
        --primary-foreground: 210 40% 98%;
        --secondary: 210 40% 96%;
        --secondary-foreground: 222.2 47.4% 11.2%;
        --muted: 210 40% 96%;
        --muted-foreground: 215.4 16.3% 46.9%;
        --accent: 210 40% 96%;
        --accent-foreground: 222.2 47.4% 11.2%;
        --destructive: 0 84.2% 60.2%;
        --destructive-foreground: 210 40% 98%;
        --border: 214.3 31.8% 91.4%;
        --input: 214.3 31.8% 91.4%;
        --ring: 222.2 84% 4.9%;
        --radius: 0.5rem;
      }

      .dark {
        --background: 216 13% 13%;
        --foreground: 210 40% 95%;
        --card: 216 13% 16%;
        --card-foreground: 210 40% 95%;
        --popover: 216 13% 16%;
        --popover-foreground: 210 40% 95%;
        --primary: 210 40% 85%;
        --primary-foreground: 216 13% 13%;
        --secondary: 216 13% 20%;
        --secondary-foreground: 210 40% 90%;
        --muted: 216 13% 20%;
        --muted-foreground: 210 20% 70%;
        --accent: 216 13% 22%;
        --accent-foreground: 210 40% 90%;
        --destructive: 0 62.8% 30.6%;
        --destructive-foreground: 210 40% 98%;
        --border: 216 13% 24%;
        --input: 216 13% 24%;
        --ring: 212.7 26.8% 83.9%;
      }

      * {
        border-color: hsl(var(--border));
      }

      body {
        background-color: hsl(var(--background));
        color: hsl(var(--foreground));
        font-family: 'Inter', ui-sans-serif, system-ui;
        font-feature-settings:
          'rlig' 1,
          'calt' 1;
        word-break: keep-all;
        word-wrap: break-word;
        line-height: 1.5;
      }

      .content-section {
        display: none;
      }
      .content-section.active {
        display: block;
        animation: fadeIn 0.3s ease-in-out;
      }

      /* Navigation Styles */
      .nav-link {
        display: block;
        padding: 0.5rem 1rem;
        margin: 0.125rem 0.5rem;
        font-size: 0.875rem;
        font-weight: 600;
        color: hsl(var(--foreground));
        text-decoration: none;
        border-radius: 0.375rem;
        transition: all 0.2s ease-in-out;
      }
      .nav-link:hover {
        color: hsl(var(--primary));
        background-color: hsl(var(--accent) / 0.5);
      }
      .nav-link.active {
        color: hsl(var(--primary));
        background-color: hsl(var(--accent));
        border-radius: 0.5rem;
      }

      .nav-sub-link {
        display: block;
        padding: 0.375rem 1rem;
        padding-left: 2rem;
        margin: 0.125rem 0.5rem;
        font-size: 0.8125rem;
        font-weight: 400;
        color: hsl(var(--muted-foreground));
        text-decoration: none;
        border-radius: 0.375rem;
        transition: all 0.2s ease-in-out;
      }
      .nav-sub-link:hover {
        color: hsl(var(--foreground));
        background-color: hsl(var(--accent) / 0.5);
      }
      .nav-sub-link.active {
        color: hsl(var(--primary));
        background-color: hsl(var(--muted));
        border-radius: 0.5rem;
      }

      /* Card Styles */
      .card {
        background-color: hsl(var(--card));
        border: 1px solid hsl(var(--border));
        border-radius: calc(var(--radius) + 2px);
        box-shadow:
          0 1px 3px 0 rgb(0 0 0 / 0.1),
          0 1px 2px -1px rgb(0 0 0 / 0.1);
        padding: 1.5rem;
        transition: all 0.2s ease-in-out;
      }
      .card:hover {
        box-shadow:
          0 4px 6px -1px rgb(0 0 0 / 0.1),
          0 2px 4px -2px rgb(0 0 0 / 0.1);
      }
      .card-header {
        padding: 1.5rem 1.5rem 0;
      }
      .card-content {
        padding: 1.5rem;
      }
      .card-title {
        font-size: 1.25rem;
        font-weight: 600;
        margin-bottom: 0.5rem;
        color: hsl(var(--card-foreground));
      }
      .card-description {
        color: hsl(var(--muted-foreground));
        line-height: 1.5;
      }

      /* Button Styles */
      .btn {
        display: inline-flex;
        align-items: center;
        justify-content: center;
        border-radius: calc(var(--radius) - 2px);
        font-size: 0.875rem;
        font-weight: 500;
        transition: all 0.2s ease-in-out;
        padding: 0.5rem 1rem;
        border: 1px solid transparent;
        cursor: pointer;
      }
      .btn:focus-visible {
        outline: none;
        ring: 2px;
        ring-color: hsl(var(--ring));
        ring-offset: 2px;
      }
      .btn:disabled {
        pointer-events: none;
        opacity: 0.5;
      }
      .btn-primary {
        background-color: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }
      .btn-primary:hover {
        background-color: hsl(var(--primary) / 0.9);
      }
      .btn-secondary {
        background-color: hsl(var(--secondary));
        color: hsl(var(--secondary-foreground));
      }
      .btn-secondary:hover {
        background-color: hsl(var(--secondary) / 0.8);
      }
      .btn-outline {
        border: 1px solid hsl(var(--border));
        background-color: hsl(var(--background));
        color: hsl(var(--foreground));
      }
      .btn-outline:hover {
        background-color: hsl(var(--accent));
        color: hsl(var(--accent-foreground));
      }

      /* Badge Styles */
      .badge {
        display: inline-flex;
        align-items: center;
        border-radius: calc(var(--radius) - 2px);
        padding: 0.25rem 0.5rem;
        font-size: 0.75rem;
        font-weight: 500;
        transition: all 0.2s ease-in-out;
        border: 1px solid transparent;
      }
      .badge-default {
        background-color: hsl(var(--primary));
        color: hsl(var(--primary-foreground));
      }
      .badge-secondary {
        background-color: hsl(var(--secondary));
        color: hsl(var(--secondary-foreground));
      }
      .badge-outline {
        border: 1px solid hsl(var(--border));
        color: hsl(var(--foreground));
      }

      /* Section spacing for better visual separation */
      .content-section > div[id] {
        margin-top: 3rem;
        padding-top: 2rem;
        border-top: 1px solid hsl(var(--border));
      }
      .content-section > div[id]:first-of-type {
        margin-top: 2rem;
        border-top: none;
      }

      /* Chart Container */
      .chart-container {
        position: relative;
        width: 100%;
        max-width: 600px;
        margin-left: auto;
        margin-right: auto;
        height: 320px;
        max-height: 400px;
        background-color: hsl(var(--card));
        border: 1px solid hsl(var(--border));
        border-radius: calc(var(--radius) + 2px);
        padding: 1rem;
      }
      @media (min-width: 768px) {
        .chart-container {
          height: 350px;
        }
      }

      /* Timeline Styles */
      .timeline-item {
        position: relative;
        padding-bottom: 2rem;
        padding-left: 2.5rem;
        border-left: 2px solid hsl(var(--border));
      }
      .timeline-dot {
        position: absolute;
        left: -0.6rem;
        top: 0.1rem;
        height: 1.125rem;
        width: 1.125rem;
        border-radius: 9999px;
        border-width: 2px;
        border-color: hsl(var(--background));
        background-color: hsl(var(--muted-foreground));
      }
      .timeline-item.active .timeline-dot {
        background-color: hsl(var(--primary));
      }
      .timeline-item.active .timeline-title {
        color: hsl(var(--primary));
      }

      /* Animations */
      .fade-in {
        animation: fadeIn 0.5s ease-in-out;
      }
      @keyframes fadeIn {
        from {
          opacity: 0;
          transform: translateY(10px);
        }
        to {
          opacity: 1;
          transform: translateY(0);
        }
      }

      /* Diagram Arrow */
      .diagram-arrow {
        position: relative;
        display: inline-block;
        width: 30px;
        height: 2px;
        background-color: hsl(var(--muted-foreground));
        margin: 0 5px;
      }
      .diagram-arrow::after {
        content: '';
        position: absolute;
        right: 0;
        top: -4px;
        width: 0;
        height: 0;
        border-top: 5px solid transparent;
        border-bottom: 5px solid transparent;
        border-left: 8px solid hsl(var(--muted-foreground));
      }

      /* Dark mode toggle */
      .dark-mode-toggle {
        position: fixed;
        top: 1rem;
        right: 2rem;
        z-index: 50;
        width: 2.5rem;
        height: 2.5rem;
        display: flex;
        align-items: center;
        justify-content: center;
        background-color: hsl(var(--card));
        border: 1px solid hsl(var(--border));
        border-radius: calc(var(--radius) + 2px);
        box-shadow:
          0 4px 6px -1px rgb(0 0 0 / 0.1),
          0 2px 4px -2px rgb(0 0 0 / 0.1);
        cursor: pointer;
        transition: all 0.2s ease-in-out;
      }
      .dark-mode-toggle:hover {
        box-shadow:
          0 10px 15px -3px rgb(0 0 0 / 0.1),
          0 4px 6px -4px rgb(0 0 0 / 0.1);
      }
    </style>
  </head>
  <body>
    <!-- Dark Mode Toggle -->
    <button class="dark-mode-toggle btn btn-outline" onclick="toggleDarkMode()">
      <span class="dark-mode-icon">◐</span>
    </button>

    <script src="https://cdnjs.cloudflare.com/ajax/libs/highlight.js/11.9.0/highlight.min.js"></script>
    <script>
      hljs.highlightAll();
    </script>
    <div class="flex h-screen">
      <!-- Sidebar Navigation -->
      <aside
        class="w-80 flex-shrink-0 card border-r border-border flex flex-col"
      >
        <div
          class="h-16 flex items-center justify-center border-b border-border flex-shrink-0"
        >
          <h1 class="text-xl font-bold text-primary">FE 트렌드 2025</h1>
        </div>
        <nav class="flex-1 overflow-y-auto mt-4 pb-4">
          <a href="#intro" class="nav-link flex items-center py-3">
            <span class="mr-3">👋</span> 개요
          </a>
          <a
            href="#intro-evolution"
            class="nav-sub-link flex items-center py-2"
          >
            FE 진화 타임라인
          </a>
          <a
            href="#intro-misconceptions"
            class="nav-sub-link flex items-center py-2"
          >
            오해와 현실
          </a>
          <a
            href="#intro-complexity"
            class="nav-sub-link flex items-center py-2"
          >
            복잡성 증가 배경
          </a>

          <a href="#jquery-era" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🗺️</span> jQuery와 웹앱의 태동
          </a>

          <a href="#spa-era" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">📱</span> SPA 프레임워크 시대
          </a>

          <a href="#trend1" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🚀</span> 트렌드 1: 메타 프레임워크
          </a>
          <a href="#trend1-meta" class="nav-sub-link flex items-center py-2">
            메타 프레임워크란?
          </a>
          <a
            href="#trend1-server-client"
            class="nav-sub-link flex items-center py-2"
          >
            Server/Client Components
          </a>
          <a
            href="#trend1-optimization"
            class="nav-sub-link flex items-center py-2"
          >
            렌더링 최적화
          </a>

          <a href="#trend2" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🛠️</span> 트렌드 2: DX 중심 툴링
          </a>
          <a href="#trend2-build" class="nav-sub-link flex items-center py-2">
            빌드 도구 진화
          </a>
          <a href="#trend2-test" class="nav-sub-link flex items-center py-2">
            테스트 생태계
          </a>
          <a href="#trend2-ai" class="nav-sub-link flex items-center py-2">
            AI 보조 도구
          </a>

          <a href="#trend3" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🎨</span> 트렌드 3: UI/UX & 상태 관리
          </a>
          <a
            href="#trend3-state-paradigm"
            class="nav-sub-link flex items-center py-2"
          >
            상태 관리 패러다임
          </a>
          <a
            href="#trend3-state-libs"
            class="nav-sub-link flex items-center py-2"
          >
            주요 상태 관리 라이브러리
          </a>
          <a
            href="#trend3-design-collab"
            class="nav-sub-link flex items-center py-2"
          >
            디자이너 협업 강화
          </a>

          <a href="#trend4" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🔗</span> 트렌드 4: 풀스택화
          </a>
          <a
            href="#trend4-fullstack-tech"
            class="nav-sub-link flex items-center py-2"
          >
            풀스택 기술
          </a>
          <a
            href="#trend4-cloud-integration"
            class="nav-sub-link flex items-center py-2"
          >
            클라우드 통합
          </a>

          <a href="#trend5" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🧑‍🚀</span> 트렌드 5: 역할 확장
          </a>
          <a
            href="#trend5-roles-detail"
            class="nav-sub-link flex items-center py-2"
          >
            역할 확장 상세
          </a>

          <a href="#collaboration" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🤝</span> 백엔드 협업 가이드
          </a>
          <a
            href="#collaboration-overview"
            class="nav-sub-link flex items-center py-2"
          >
            협업 개요
          </a>
          <a href="#collaboration1" class="nav-sub-link flex items-center py-2">
            API 명세와 타입 공유
          </a>
          <a href="#collaboration2" class="nav-sub-link flex items-center py-2">
            통신 구조 모던화
          </a>
          <a href="#collaboration3" class="nav-sub-link flex items-center py-2">
            성능 최적화 기법 이해
          </a>
          <a href="#conclusion" class="nav-link flex items-center py-3 px-4">
            <span class="mr-3">🎯</span> 결론
          </a>
        </nav>
      </aside>

      <!-- Main Content -->
      <main
        class="flex-1 overflow-y-auto bg-background px-10 justify-center flex"
      >
        <div class="p-6 md:p-8 max-w-5xl">
          <!-- Section: Intro -->
          <section id="intro" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              Intro - 프론트엔드는 여전히 HTML + CSS + JS?
            </h2>
            <p class="text-muted-foreground mb-8">
              프론트엔드 개발의 진화와 현재 마주한 복잡성에 대한 개요입니다.
            </p>

            <!-- Sub-Section: Intro - Evolution Timeline -->
            <div id="intro-evolution">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                FE 개발의 진화 타임라인
              </h3>
              <p class="text-muted-foreground mb-8">
                프론트엔드 기술은 웹의 발전과 함께 끊임없이 진화해왔습니다. 각
                시대별 주요 특징을 통해 현재의 복잡성을 이해할 수 있습니다.
              </p>
              <div class="card mb-8">
                <div id="timeline-container">
                  <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <h4
                      class="timeline-title text-lg font-semibold text-muted-foreground"
                    >
                      jQuery 시대 (~2010년대 초반)
                    </h4>
                    <p class="text-sm text-muted-foreground">
                      AJAX와 동적 UI의 대중화
                    </p>
                    <p class="mt-2 text-muted-foreground">
                      페이지 새로고침 없이 서버와 통신하는 AJAX 기술이
                      대중화되며, 웹이 정적인 문서를 넘어 동적인
                      애플리케이션으로 발전하는 기반을 마련했습니다.
                      <a
                        href="#jquery-era"
                        class="text-primary hover:underline font-semibold"
                        onclick="document.querySelector('a[href=\'#jquery-era\']').click(); return false;"
                        >자세히 알아보기 &rarr;</a
                      >
                    </p>
                  </div>
                  <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <h4
                      class="timeline-title text-lg font-semibold text-muted-foreground"
                    >
                      SPA 프레임워크 시대 (2010년대 중반~)
                    </h4>
                    <p class="text-sm text-muted-foreground">
                      React, Vue, Angular의 등장
                    </p>
                    <p class="mt-2 text-muted-foreground">
                      클라이언트 사이드 렌더링(CSR) 기반의 SPA(Single Page
                      Application)가 대세가 되었습니다. 프론트엔드는 복잡한 UI와
                      상태 관리를 직접 담당하며 '애플리케이션'의 면모를 갖추게
                      됩니다.
                      <a
                        href="#spa-era"
                        class="text-primary hover:underline font-semibold"
                        onclick="document.querySelector('a[href=\'#spa-era\']').click(); return false;"
                        >자세히 알아보기 &rarr;</a
                      >
                    </p>
                  </div>
                  <div class="timeline-item">
                    <div class="timeline-dot"></div>
                    <h4
                      class="timeline-title text-lg font-semibold text-muted-foreground"
                    >
                      메타 프레임워크 시대 (2020년대~)
                    </h4>
                    <p class="text-sm text-muted-foreground">
                      Next.js, Nuxt.js, Remix 등
                    </p>
                    <p class="mt-2 text-muted-foreground">
                      SPA의 단점을 보완하고 SEO, 초기 로딩 속도, 사용자 경험(UX)
                      개선을 위해 SSR, SSG 등 다양한 렌더링 전략이 도입된
                      프레임워크들이 등장했습니다. 프론트엔드 개발이
                      클라이언트뿐만 아니라 서버 영역까지 확장되기 시작하며
                      풀스택에 가까워지고 있습니다.
                    </p>
                  </div>
                </div>
              </div>
            </div>

            <!-- Sub-Section: Intro - Misconceptions -->
            <div id="intro-misconceptions">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                프론트엔드에 대한 일반적인 오해와 현실
              </h3>
              <p class="text-muted-foreground mb-8">
                "프론트엔드는 그냥 화면 그리는 거 아니야?"라는 오해는 과거의
                프론트엔드에 대한 시각입니다. 지금의 프론트엔드는 훨씬 더
                복잡하고 전략적인 역할을 수행합니다.
              </p>
              <div class="card mb-8">
                <div class="grid grid-cols-1 md:grid-cols-2 gap-8">
                  <div class="border-r-0 md:border-r md:pr-8 border-border">
                    <h4 class="text-xl font-bold text-muted-foreground mb-4">
                      🤔 과거의 오해
                    </h4>
                    <ul class="space-y-4 text-muted-foreground">
                      <li class="flex items-start">
                        <span class="mr-3 text-lg">🎨</span>
                        <div>
                          <p class="font-semibold">"그냥 화면 그리는 일"</p>
                          <p class="text-sm">
                            디자이너가 넘겨준 시안을 단순히 HTML, CSS로 옮기는
                            작업으로 인식되었습니다.
                          </p>
                        </div>
                      </li>
                      <li class="flex items-start">
                        <span class="mr-3 text-lg">📥</span>
                        <div>
                          <p class="font-semibold">
                            "백엔드가 주는 데이터만 뿌려주는 역할"
                          </p>
                          <p class="text-sm">
                            백엔드 API에서 받은 데이터를 화면에 표시하는 것이
                            주된 역할로 한정되었습니다.
                          </p>
                        </div>
                      </li>
                      <li class="flex items-start">
                        <span class="mr-3 text-lg">📉</span>
                        <div>
                          <p class="font-semibold">"기술적 깊이가 얕다"</p>
                          <p class="text-sm">
                            백엔드에 비해 상대적으로 단순하고 깊이 있는 기술적
                            지식이 덜 필요하다고 여겨졌습니다.
                          </p>
                        </div>
                      </li>
                    </ul>
                  </div>
                  <div>
                    <h4 class="text-xl font-bold text-primary mb-4">
                      🚀 현재의 현실
                    </h4>
                    <ul class="space-y-4 text-foreground">
                      <li class="flex items-start">
                        <span class="mr-3 text-lg">🧑‍🎨</span>
                        <div>
                          <p class="font-semibold">
                            "사용자 경험(UX) 전체를 설계"
                          </p>
                          <p class="text-sm">
                            단순한 화면 구현을 넘어, 사용자의 전체적인 경험
                            흐름을 설계하고 개선하며 비즈니스 목표 달성에 직접
                            기여합니다.
                          </p>
                        </div>
                      </li>
                      <li class="flex items-start">
                        <span class="mr-3 text-lg">⚙️</span>
                        <div>
                          <p class="font-semibold">
                            "클라이언트에서 비즈니스 로직 처리"
                          </p>
                          <p class="text-sm">
                            상태 관리, 데이터 가공, 유효성 검사 등 복잡한
                            비즈니스 로직을 클라이언트 단에서 직접 처리합니다.
                          </p>
                        </div>
                      </li>
                      <li class="flex items-start">
                        <span class="mr-3 text-lg">🛡️</span>
                        <div>
                          <p class="font-semibold">
                            "성능, 보안, 접근성을 책임지는 아키텍트"
                          </p>
                          <p class="text-sm">
                            웹 성능 최적화, 보안 취약점 방어, 웹 접근성 준수 등
                            비기능적 요구사항까지 책임지는 아키텍트의 역할을
                            수행합니다.
                          </p>
                        </div>
                      </li>
                    </ul>
                  </div>
                </div>
                <p class="mt-8 text-center p-4 rounded-md">
                  결론적으로, 현대의 프론트엔드 개발자는 제품의 가장 중요한
                  사용자 접점을 책임지는 <strong>'제품 아키텍트'</strong>이자
                  백엔드의 <strong>'전략적 파트너'</strong>로 진화했습니다.
                </p>
              </div>
            </div>

            <!-- Sub-Section: Intro - Complexity Background -->
            <div id="intro-complexity">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                "요즘 프론트 개발자 뭐가 이렇게 많냐"는 말의 배경
              </h3>
              <p class="text-muted-foreground mb-8">
                프론트엔드 개발의 복잡성이 급증하면서, 학습해야 할 기술 스택과
                담당해야 할 역할이 크게 늘어났습니다.
              </p>
              <div class="card p-6 rounded-md">
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong>복잡성 증가:</strong> 사용자 요구사항 증대, 다양한
                    디바이스 및 플랫폼(웹, 모바일 웹, 데스크톱 앱 등) 지원,
                    실시간 상호작용, 복잡한 애니메이션 등으로 인해 UI/UX 구현의
                    복잡성이 기하급수적으로 증가했습니다.
                  </li>
                  <li>
                    <strong>기술 스택의 다양화:</strong> 단순히 HTML, CSS,
                    JavaScript를 넘어 프레임워크(React, Vue), 번들러(Webpack,
                    Vite), 트랜스파일러(Babel), 상태 관리 라이브러리(Redux,
                    Zustand), 테스트 도구(Jest, Playwright), UI 컴포넌트
                    라이브러리(Material UI, Ant Design) 등 선택하고 학습해야 할
                    기술 스택이 매우 많아졌습니다.
                  </li>
                  <li>
                    <strong>역할의 확장:</strong> 단순 UI 구현을 넘어 웹 성능
                    최적화(번들링, 코드 스플리팅, 캐싱), 검색 엔진 최적화(SEO),
                    웹 접근성(Accessibility), 보안(XSS, CSRF 방어), 모니터링,
                    데이터 시각화 등 다양한 영역을 고려하고 책임져야 합니다.
                    이는 과거 백엔드나 인프라 영역으로 여겨지던 부분까지
                    포함합니다.
                  </li>
                </ul>
              </div>
            </div>
          </section>

          <!-- Section: jQuery Era -->
          <section id="jquery-era" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              🗺️ jQuery와 웹 애플리케이션의 태동
            </h2>

            <h3 class="text-xl font-bold mb-4 text-foreground mt-12">
              jQuery: AJAX와 DOM 조작의 간소화
            </h3>
            <p class="text-muted-foreground mb-4">
              이러한 AJAX 기반의 동적 UI 구현을 매우 쉽게 만들어준 라이브러리가
              바로
              <strong
                ><a
                  class="text-blue-500 underline"
                  href="https://jquery.com"
                  target="_blank"
                  >jQuery</a
                ></strong
              >입니다. 짧고 직관적인 코드로 AJAX 통신과 DOM 조작을 가능하게 하여
              폭발적인 인기를 끌었습니다.
            </p>
            <div class="mt-4 rounded-md text-sm font-mono overflow-x-auto">
              <pre><code>// HTML: &lt;button id="load-data"&gt;데이터 로드&lt;/button&gt;&lt;div id="results"&gt;&lt;/div&gt;
// 버튼 클릭 시, 페이지 새로고침 없이 서버에서 데이터를 비동기로 가져옵니다.
$('#load-data').on('click', function() {
  $.ajax({
    url: '/api/items', // 백엔드 API 엔드포인트
    success: function(data) { // 통신 성공 시
      // 기존 내용을 비우고,
      $('#results').empty();
      
      // 받은 데이터로 새로운 HTML 요소를 만들어 DOM에 직접 추가합니다.
      $.each(data, function(index, item) {
        $('#results').append('&lt;div class="item"&gt;' + item.name + '&lt;/div&gt;');
      });
    }
  });
});</code></pre>
            </div>
            <p class="text-muted-foreground mt-4">
              특히 당시 시장 점유율이 높았던 Internet Explorer의 비표준 구현에도
              잘 대응하여, 수많은 기업 웹사이트와 포털, 정부 시스템까지도
              jQuery를 채택하게 되었습니다.
            </p>
            <div class="flex justify-center">
              <img
                src="/images/cross_browsing.jpg"
                class="border border-border rounded-md"
                width="520px"
              />
            </div>
            <p class="text-muted-foreground mt-4">
              그 결과, jQuery는 곧 웹 프론트엔드의
              <strong>사실상 표준 라이브러리</strong>로 자리잡게 되었고, 이후의
              웹 개발 생태계에도 큰 영향을 미쳤습니다.
            </p>
            <h3 class="text-xl font-bold mb-4 text-foreground mt-12">
              새로고침 없는 지도: 웹 애플리케이션의 시작
            </h3>
            <p class="text-muted-foreground mb-8">
              2005년 구글맵의 등장은 웹 개발 패러다임에 큰 충격을 주었습니다.
              페이지 전체를 새로고침하지 않고도 지도를 부드럽게 이동하고,
              확대/축소하며, 마커를 표시하는 경험은 당시로서는 혁신적이었습니다.
              이 경험의 핵심 기술이 바로
              <strong>AJAX(Asynchronous JavaScript and XML)</strong>였습니다.
            </p>
            <div class="card mb-8">
              <img
                src="images/google_map2.gif"
                alt="초기 구글맵 UI"
                class="w-full h-auto rounded-md mb-6 shadow-md"
              />
              <div class="text-center mb-8">
                더 많은 정보를 얻고 싶다면
                <a
                  class="text-blue-400 hover:underline"
                  target="_blank"
                  href="https://medium.com/google-design/google-maps-cb0326d165f5"
                  >미디움</a
                >
                클릭
              </div>
              <p class="text-muted-foreground mb-4">
                구글맵은 Canvas나 WebGL 같은 현대 그래픽 기술이 아닌,
                <strong
                  >전통적인 DOM 요소(수많은 작은 지도 이미지 조각)와
                  JavaScript만으로 이 모든 것을 구현</strong
                >했습니다. 사용자가 지도를 드래그하면, 보이지 않는 영역의 지도
                이미지 타일을 백그라운드에서 비동기적으로(AJAX) 서버에 요청하고,
                받아온 이미지들을 DOM에 동적으로 추가/교체하는 방식이었습니다.
              </p>
              <p class="text-muted-foreground mb-4">
                이러한 '비동기 통신'과 '동적 DOM 조작'의 조합은 정적인 HTML
                문서가 사용자와 실시간으로 상호작용하는
                <strong>'웹 애플리케이션'으로 진화하는 결정적인 계기</strong>가
                되었습니다. 이는 페이지 전체를 하나의 애플리케이션으로 관리하는
                이후의
                <strong>SPA(Single Page Application) 시대의 명백한 전조</strong
                >였습니다.
              </p>
            </div>
          </section>

          <!-- Section: SPA Era -->
          <section id="spa-era" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              📱 SPA 프레임워크 시대: React, Vue, Angular
            </h2>
            <p class="text-muted-foreground mb-8">
              jQuery 시대가 웹의 동적인 가능성을 열어주었다면, SPA(Single Page
              Application) 프레임워크의 등장은 현대적인 웹 애플리케이션의 시대를
              본격적으로 열었습니다. 사용자는 더 이상 새로운 정보를 볼 때마다
              페이지 전체가 하얗게 깜빡이며 새로고침되는 것을 경험하지 않아도
              되었습니다. 대신, 필요한 데이터만 서버와 주고받아 화면의 일부만
              부드럽게 업데이트하며 마치 데스크톱 애플리케이션과 같은 사용자
              경험(UX)을 누릴 수 있게 되었죠. 이 혁신의 중심에는 Angular, React,
              Vue라는 세 거인이 있습니다.
            </p>

            <div class="card mb-8">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                초기 SPA 프레임워크의 등장 (2008 ~ 2012)
              </h3>
              <div
                class="flex items-start space-x-4 p-4 border border-gray-200 rounded-md"
              >
                <span class="text-4xl">
                  <img src="images/angular.png" alt="Angular" width="200px" />
                </span>
                <div>
                  <h4 class="font-bold text-lg text-foreground">
                    AngularJS (2010)
                  </h4>
                  <p class="text-muted-foreground">
                    구글에서 개발한 AngularJS는 '프레임워크'라는 이름에 걸맞게
                    웹 애플리케이션 개발에 필요한 거의 모든 기능(라우팅, 데이터
                    관리, 템플릿 등)을 갖춘 'All-in-one' 솔루션이었습니다. 특히
                    <strong>양방향 데이터 바인딩(Two-way Data Binding)</strong
                    >과 <strong>디렉티브(Directives)</strong>라는 개념은
                    혁신적이었습니다. 개발자가 DOM을 직접 조작하는 코드 없이,
                    데이터 모델(Model)의 변경이 즉시 화면(View)에 반영되고,
                    반대로 사용자 입력으로 인한 화면의 변경이 데이터 모델에
                    자동으로 반영되게 만들었습니다. 이는 개발 생산성을 극적으로
                    향상시켰습니다.
                  </p>
                </div>
              </div>
              <p class="mt-4 font-semibold">
                기술적 흐름: 클라이언트 렌더링의 본격화
              </p>
              <p class="text-muted-foreground mt-2">
                AngularJS의 등장은 웹 개발의 패러다임을 바꾸는 신호탄이었습니다.
                과거 서버가 담당했던 HTML 생성, 페이지 구성, 상태 관리 등의
                역할이 대거 브라우저(클라이언트)로 넘어오기 시작했습니다. 이로
                인해 백엔드는 화면을 고려하지 않고 순수하게 데이터만 제공하는
                <strong>API 서버(주로 RESTful API)</strong>의 역할에 집중하게
                되는 '역할의 분리'가 가속화되었습니다.
              </p>
            </div>

            <div class="card mb-8">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                SPA의 대중화와 React, Vue의 등판 (2013 ~ 2016)
              </h3>
              <div
                class="flex items-start space-x-4 p-4 border border-gray-200 rounded-md mb-4"
              >
                <span class="text-4xl">
                  <img src="images/react.png" alt="react" width="92px" />
                </span>
                <div>
                  <h4 class="font-bold text-lg text-foreground">
                    React (2013)
                  </h4>
                  <p class="text-muted-foreground">
                    페이스북이 발표. '프레임워크'가 아닌 'View 라이브러리'임을
                    표방하며, 필요한 부분에만 적용할 수 있는 유연성을
                    제공했습니다.
                    <strong
                      >선언형 UI, Virtual DOM, 컴포넌트 기반 아키텍처</strong
                    >라는 혁신적인 개념으로 개발자들에게 폭발적인 반응을 얻으며
                    SPA 개발의 표준으로 자리 잡게 됩니다.
                  </p>
                  <ul class="mt-6 list-disc pl-6">
                    <li>
                      선언형 UI: "어떻게" 그릴지(How)가 아닌 "무엇을"
                      그릴지(What)에 집중하게 하여 코드의 가독성과 예측 가능성을
                      높였습니다.
                    </li>
                    <li>
                      Virtual DOM: 실제 DOM을 직접 조작하는 대신, 메모리상에
                      가상의 DOM을 두고 변경 사항을 한 번에 계산(diffing)하여
                      실제 DOM에는 최소한의 변경만 적용했습니다. 이는 복잡한
                      애플리케이션에서 놀라운 렌더링 성능을 보여주었습니다.
                    </li>
                    <li>
                      컴포넌트 기반 아키텍처: UI를 독립적인 기능을 가진 레고
                      블록과 같은 '컴포넌트'로 분리하여 재사용성을 극대화하고,
                      복잡한 UI를 체계적으로 관리할 수 있게 했습니다.
                    </li>
                  </ul>
                </div>
              </div>
              <div
                class="flex items-start space-x-4 p-4 border border-gray-200 rounded-md mb-4"
              >
                <span class="text-4xl">
                  <img src="images/vue.png" alt="vue" width="92px" />
                </span>
                <div>
                  <h4 class="font-bold text-lg text-foreground">
                    Vue.js (2014)
                  </h4>
                  <p class="text-muted-foreground">
                    구글에서 AngularJS 프로젝트에 참여했던 개발자 에반 유(Evan
                    You)가 발표한 Vue.js는 "두 거인의 장점을 흡수하고 단점을
                    개선하면 어떨까?"라는 생각에서 출발했습니다. 그는
                    AngularJS의 쉬운 데이터 바인딩과 React의 반응형 컴포넌트
                    아키텍처에서 영감을 받아, 이 둘을 결합하여 훨씬 가볍고
                    배우기 쉬운 프레임워크를 만들었습니다.
                  </p>
                </div>
              </div>
            </div>

            <p class="mt-4 font-semibold">SPA 기술 트렌드의 정착:</p>
            <div class="mt-2 grid grid-cols-1 sm:grid-cols-3 gap-4">
              <div class="flex items-center space-x-2 p-3 bg-accent rounded-md">
                <span class="text-2xl">🔄</span>
                <div>
                  <p class="font-semibold">상태 관리</p>
                  <p class="text-xs text-muted-foreground">Redux, MobX</p>
                </div>
              </div>
              <div class="flex items-center space-x-2 p-3 bg-accent rounded-md">
                <span class="text-2xl">🧭</span>
                <div>
                  <p class="font-semibold">클라이언트 라우팅</p>
                  <p class="text-xs text-muted-foreground">React Router</p>
                </div>
              </div>
              <div class="flex items-center space-x-2 p-3 bg-accent rounded-md">
                <span class="text-2xl">📦</span>
                <div>
                  <p class="font-semibold">빌드 시스템</p>
                  <p class="text-xs text-muted-foreground">Webpack, Babel</p>
                </div>
              </div>
            </div>
            <p class="text-muted-foreground mt-4">
              React의 등장과 함께, 복잡해진 애플리케이션의 상태를 효율적으로
              관리하기 위한 상태 관리 라이브러리, 페이지 이동을 처리하는 라우팅
              라이브러리, 최신 JavaScript 문법 사용과 코드 번들링을 위한 빌드
              시스템이 SPA 개발의 필수 요소로 자리 잡았습니다.
            </p>

            <p class="mt-6 p-4 bg-accent rounded-md border border-border">
              <strong class="text-primary"
                >백엔드 개발자에게 주는 시사점:</strong
              >
              SPA 시대의 도래는 백엔드 팀의 역할을 '데이터 API 서버'로 명확히
              규정했습니다. 프론트엔드에서 필요한 모든 데이터를 효율적으로
              제공하기 위한 RESTful API 설계의 중요성이 크게 부각되었고, 이는
              현재까지도 백엔드 개발의 핵심 역량으로 자리 잡고 있습니다. SPA의
              단점들, 특히 SEO와 초기 로딩 문제는 이후 메타 프레임워크의 등장을
              촉발하는 중요한 계기가 됩니다.
            </p>

            <div class="card p-6 rounded-md mb-8 mt-12">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                SPA의 핵심 동작 원리: 어떻게 한 페이지로 동작할까?
              </h3>
              <p class="text-muted-foreground mb-4">
                SPA는 이름처럼 단 하나의 HTML 페이지로 시작합니다. 그렇다면
                어떻게 다른 내용을 보여줄 수 있을까요? 그 비밀은 JavaScript에
                있습니다. 전체 과정을 간단한 코드로 살펴보겠습니다.
              </p>

              <div class="mb-6">
                <h4 class="font-semibold text-lg mb-2">
                  1. 최초 요청: 서버는 뼈대만 보낸다
                </h4>
                <p class="text-muted-foreground mb-2">
                  사용자가 사이트에 처음 접속하면, 서버는 내용이 비어있는
                  <strong>`index.html`</strong> 파일 하나와, 애플리케이션의 모든
                  로직이 담긴 <strong>JavaScript 파일(`app.js`)</strong>을
                  브라우저에 보내줍니다.
                </p>
                <pre><code class="language-html bg-gray-800 text-white text-sm rounded-md block p-4 overflow-x-auto">&lt;!DOCTYPE html&gt;
&lt;html lang=""&gt;
  &lt;head&gt;
    &lt;meta charset="UTF-8"&gt;
    &lt;link rel="icon" href="/favicon.ico"&gt;
    &lt;meta name="viewport" content="width=device-width, initial-scale=1.0"&gt;
    &lt;title&gt;Vite App&lt;/title&gt;
    &lt;script type="module" crossorigin src="/assets/app.js"&gt;&lt;/script&gt;
    &lt;link rel="stylesheet" crossorigin href="/assets/index-TXLObeWa.css"&gt;
  &lt;/head&gt;
  &lt;body&gt;
    &lt;div id="app"&gt;&lt;/div&gt;
  &lt;/body&gt;
&lt;/html&gt;
</code></pre>
              </div>

              <div class="mb-6">
                <h4 class="font-semibold text-lg mb-2">
                  2. 브라우저: JavaScript가 모든 것을 그린다
                </h4>
                <p class="text-muted-foreground mb-2">
                  브라우저는 `index.html`과 `app.js`를 받은 후, `app.js`를
                  실행합니다. 이 스크립트는 비어있던 `&lt;div id="root"&gt;`를
                  찾아 초기 화면(예: 홈페이지)을 그려 넣습니다. 그리고
                  `&lt;nav&gt;`의 링크 클릭을 감시하기 시작합니다.
                </p>
                <pre><code class="language-javascript text-sm rounded-md block p-4 bg-gray-800 text-white overflow-x-auto">// app.js - 실제 프레임워크는 훨씬 정교하지만, 원리는 동일합니다.

// 1. 콘텐츠를 그려넣을 캔버스를 찾습니다.
const root = document.getElementById('root');

// 2. 각 경로에 맞는 페이지 내용을 정의합니다. (실제로는 HTML 템플릿)
const routes = {
  '/': '&lt;h1&gt;홈페이지에 오신 것을 환영합니다!&lt;/h1&gt;',
  '/about': '&lt;h1&gt;저희는 멋진 회사입니다.&lt;/h1&gt;&lt;p&gt;데이터 로딩 중...&lt;/p&gt;',
};

// 3. 브라우저 주소에 따라 적절한 페이지를 그리는 함수
const render = (path) => {
  root.innerHTML = routes[path] || '&lt;h1&gt;404 Not Found&lt;/h1&gt;';
};

// 4. 사용자가 링크를 클릭했을 때의 동작을 정의
document.addEventListener('click', (e) => {
  // 클릭된 것이 탐색 링크(&lt;a&gt;)가 맞는지 확인
  if (e.target.tagName === 'A') {
    e.preventDefault(); // 중요: 페이지 새로고침을 막습니다!
    const path = e.target.getAttribute('href');
    
    // 주소창의 URL을 프로그래밍 방식으로 변경
    history.pushState(null, null, path); 
    
    // 새로운 경로에 맞는 화면을 다시 그림
    render(path);
    
    // 만약 '/about' 페이지라면 서버에 추가 데이터 요청
    if (path === '/about') {
      fetch('/api/company-info') // 서버에 데이터만 요청 (HTML 아님)
        .then(response => response.json()) // JSON 형태로 파싱
        .then(data => {
          // 데이터 로딩이 끝나면 내용 업데이트
          root.querySelector('p').textContent = data.description;
        });
    }
  }
});

// 5. 첫 페이지 로딩
render(window.location.pathname);
</code></pre>
              </div>

              <div>
                <h4 class="font-semibold text-lg mb-2">
                  정리: SPA의 동작 흐름
                </h4>
                <ol
                  class="list-decimal list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong>최초 로드:</strong> 브라우저는 서버로부터 뼈대
                    `index.html`과 두뇌 `app.js`를 받습니다.
                  </li>
                  <li>
                    <strong>초기 렌더링:</strong> `app.js`가 실행되어 `&lt;div
                    id="root"&gt;` 안에 초기 페이지를 그립니다.
                  </li>
                  <li>
                    <strong>내부 이동:</strong> 사용자가 링크를 클릭하면,
                    `app.js`가 페이지 새로고침을 막고, 주소창의 주소만 바꿉니다.
                  </li>
                  <li>
                    <strong>동적 렌더링 & 데이터 요청:</strong> `app.js`는
                    새로운 주소에 맞는 화면을 `&lt;div id="root"&gt;`에 다시
                    그리고, 필요하다면 서버에
                    <strong>데이터(JSON)만</strong> 요청하여 화면의 일부를
                    업데이트합니다.
                  </li>
                </ol>
                <p class="text-muted-foreground mt-4">
                  이처럼 SPA는 최초에 한 번만 페이지 전체를 받고, 이후에는
                  JavaScript가 서버와는 데이터로만 통신하며 화면을 동적으로 계속
                  바꿔나가는 방식입니다. React, Vue, Angular와 같은 프레임워크는
                  바로 이
                  <strong
                    >DOM 조작과 상태 관리, 데이터 요청 과정을 훨씬 더 효율적이고
                    체계적으로 자동화</strong
                  >해주는 강력한 도구인 셈입니다.
                </p>
              </div>
            </div>
          </section>

          <!-- Section: Trend 1 -->
          <section id="trend1" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              트렌드 1: 메타 프레임워크의 시대
            </h2>
            <p class="text-muted-foreground mb-8">
              SPA의 단점을 극복하고 더 나은 성능과 개발 경험을 제공하기 위해,
              기존 프레임워크(React 등)를 기반으로 한 '메타 프레임워크'가
              등장했습니다.
            </p>

            <!-- Sub-Section: React 기반 메타 프레임워크 전성시대 -->
            <div id="trend1-meta">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                React 기반 메타 프레임워크 전성시대
              </h3>
              <p class="text-muted-foreground mb-8">
                React는 여전히 강력한 생태계를 가지고 있으며, 이를 기반으로 한
                메타 프레임워크들이 프론트엔드 개발의 표준이 되고 있습니다.
                이들은 개발 편의성과 성능 최적화를 동시에 제공합니다.
              </p>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="card p-6 rounded-md flex items-start space-x-4">
                  <span class="text-4xl text-primary">
                    <img
                      class="rounded-full"
                      src="images/nextjs.jpeg"
                      alt="nextjs"
                    />
                  </span>
                  <div>
                    <h4 class="text-xl font-bold mb-2 text-foreground">
                      Next.js
                    </h4>
                    <p class="text-muted-foreground">
                      React 기반의 가장 인기 있는 풀스택 프레임워크. SSR, SSG,
                      ISR 등 다양한 렌더링 방식을 지원하며 파일 시스템 기반
                      라우팅을 제공합니다. 복잡한 웹 애플리케이션 및 마케팅
                      페이지에 모두 적합합니다.
                    </p>
                  </div>
                </div>
                <div class="card p-6 rounded-md flex items-start space-x-4">
                  <span class="text-4xl text-primary">
                    <img
                      src="images/remix.png"
                      alt="remix"
                      class="rounded-full"
                    />
                  </span>
                  <div>
                    <h4 class="text-xl font-bold mb-2 text-foreground">
                      Remix
                    </h4>
                    <p class="text-muted-foreground">
                      웹 표준을 지향하며, 서버에서 데이터를 로드하고 폼 제출을
                      처리하는 등 웹의 기본 기능을 활용하여 개발을 간소화합니다.
                      특히 데이터 로딩 및 뮤테이션(데이터 변경)에 강력한 기능을
                      제공합니다.
                    </p>
                  </div>
                </div>
                <div class="card p-6 rounded-md flex items-start space-x-4">
                  <span class="text-4xl text-primary">
                    <img
                      src="images/astro.jpg"
                      alt="astro"
                      class="rounded-full"
                      width="240px"
                    />
                  </span>
                  <div>
                    <h4 class="text-xl font-bold mb-2 text-foreground">
                      Astro
                    </h4>
                    <p class="text-muted-foreground">
                      HTML 중심의 정적 사이트 생성을 목표로 하며, 필요한
                      부분에만 JavaScript를 사용하는 "Islands Architecture"를
                      통해 매우 빠른 초기 로딩 성능을 제공합니다. 블로그, 마케팅
                      사이트, 문서 사이트 등 콘텐츠 중심 웹사이트에 최적화되어
                      있습니다.
                    </p>
                  </div>
                </div>
                <div class="card p-6 rounded-md flex items-start space-x-4">
                  <span class="text-4xl text-primary">
                    <img
                      src="images/gatsby.png"
                      alt="gatsby"
                      class="rounded-full"
                    />
                  </span>
                  <div>
                    <h4 class="text-xl font-bold mb-2 text-foreground">
                      Gatsby
                    </h4>
                    <p class="text-muted-foreground">
                      React 기반의 강력한 정적 사이트 생성기(SSG)입니다.
                      GraphQL을 활용한 통합 데이터 레이어를 통해 CMS, Markdown,
                      API 등 다양한 소스에서 데이터를 쉽게 가져와 빌드 시점에
                      페이지를 생성하므로 매우 빠른 로딩 속도를 보장합니다.
                      블로그, 포트폴리오, 문서 사이트에 최적화되어 있습니다.
                    </p>
                  </div>
                </div>
              </div>
            </div>
            <!-- Sub-Section: Trend 1 - Server/Client Components -->
            <div id="trend1-server-client">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                App Router 도입과 Server Components 개념 (Next.js 중심)
              </h3>
              <p class="text-muted-foreground mb-8">
                Next.js 13부터 도입된 App Router와 Server Components는
                프론트엔드 개발 패러다임에 큰 변화를 가져왔습니다. 이는
                컴포넌트가 어디서 실행되고 데이터를 어떻게 가져오는지에 대한
                근본적인 변화를 의미합니다.
              </p>
              <div class="card p-6 rounded-md">
                <div class="flex flex-col space-y-4">
                  <div class="border border-blue-200 bg-blue-50 p-4 rounded-md">
                    <h4 class="font-bold text-blue-800">
                      💻 Server Components (서버)
                    </h4>
                    <ul
                      class="list-disc list-inside text-sm text-blue-700 mt-2 space-y-1"
                    >
                      <li>
                        <strong>실행 위치:</strong> 서버에서만 렌더링되고
                        클라이언트로 전송되지 않습니다.
                      </li>
                      <li>
                        <strong>데이터 접근:</strong> 서버 환경이므로
                        데이터베이스나 파일 시스템에 직접 접근할 수 있습니다.
                        이는 API 호출 없이도 데이터를 가져올 수 있다는 것을
                        의미하며, 백엔드 API의 부하를 줄일 수 있습니다.
                      </li>
                      <li>
                        <strong>성능 이점:</strong> 클라이언트로 전송되는
                        JavaScript 번들 크기를 줄여 초기 페이지 로딩 속도를 크게
                        향상시킵니다.
                      </li>
                      <li>
                        <strong>활용:</strong> 정적인 콘텐츠, 데이터 페칭 로직,
                        민감한 정보 처리 등에 적합합니다.
                      </li>
                    </ul>
                  </div>
                  <div
                    class="border border-green-200 bg-green-50 p-4 rounded-md"
                  >
                    <h4 class="font-bold text-green-800">
                      🖱️ Client Components (클라이언트)
                    </h4>
                    <ul
                      class="list-disc list-inside text-sm text-green-700 mt-2 space-y-1"
                    >
                      <li>
                        <strong>실행 위치:</strong> 브라우저에서 실행되며,
                        사용자 인터랙션이 필요한 부분에 사용됩니다.
                      </li>
                      <li>
                        <strong>기존 React 유사:</strong> `useState`,
                        `useEffect` 등 React Hooks를 사용하여 상태 관리 및
                        사이드 이펙트를 처리합니다.
                      </li>
                      <li>
                        <strong>활용:</strong> 클릭 이벤트, 폼 입력, 애니메이션,
                        동적인 UI 업데이트 등 사용자 상호작용이 필요한 모든
                        부분에 사용됩니다.
                      </li>
                    </ul>
                  </div>
                </div>
              </div>
            </div>
            <!-- Sub-Section: Trend 1 - Rendering Optimization -->
            <div id="trend1-optimization">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                렌더링 최적화의 진화: Hydration을 넘어 서버 컴포넌트로
              </h3>
              <p class="text-muted-foreground mb-8">
                서버에서 렌더링된 정적 HTML에 어떻게 생명을 불어넣어
                인터랙티브하게 만들 것인가? 이 질문에 대한 해답은
                'Hydration'에서 시작하여, 이제는 '어떤 컴포넌트의 JavaScript를
                보낼 것인가'를 근본적으로 다시 생각하는 패러다임으로 진화하고
                있습니다. 이 과정의 핵심 목표는 초기 JavaScript 실행 비용을
                최소화하여 사용자 경험을 극대화하는 것입니다.
              </p>
              <div class="card p-6 rounded-md space-y-6">
                <div>
                  <h4 class="text-lg font-bold text-foreground">
                    1단계: Full Hydration (전체 수화)
                  </h4>
                  <p class="text-muted-foreground mt-2">
                    서버는 브라우저에 완성된 형태의 HTML을 보냅니다. 사용자는
                    즉시 콘텐츠를 볼 수 있지만(빠른 FCP), 이 HTML은 아직
                    '그림'에 불과합니다. 상호작용을 위해서는 클라이언트에서 전체
                    페이지에 해당하는 JavaScript를 다운로드하고 실행하여, HTML
                    요소에 이벤트 리스너를 다시 연결하고 애플리케이션 상태를
                    복원해야 합니다. 이 과정을 'Hydration'이라 부릅니다.
                  </p>
                  <p class="text-sm mt-2 text-red-400">
                    <strong>문제점:</strong> 페이지가 아무리 간단해도 전체 앱의
                    JS를 실행해야 하므로, TTI(Time To Interactive, 상호작용 가능
                    시간)가 길어집니다. 사용자는 화면을 보고 있지만 버튼을
                    눌러도 한동안 반응이 없는 'Uncanny Valley' 현상을 겪게
                    됩니다.
                  </p>
                </div>
                <div class="border-t pt-6 border-border">
                  <h4 class="text-lg font-bold text-foreground">
                    2단계: Partial Hydration (부분적 수화)
                  </h4>
                  <p class="text-muted-foreground mt-2">
                    "페이지 전체가 인터랙티브할 필요는 없다"는 아이디어에서
                    출발합니다. 페이지의 대부분은 정적인 텍스트와 이미지이고,
                    실제 상호작용이 필요한 부분은 댓글창, 이미지 캐러셀 등
                    일부에 불과합니다. Partial Hydration은 바로 이 '인터랙티브한
                    컴포넌트'에 대해서만 JavaScript를 로드하고 Hydration을
                    실행합니다. 나머지 정적인 부분은 순수 HTML로 남아있습니다.
                  </p>
                  <p class="text-sm mt-2 text-green-400">
                    <strong>개선점:</strong> 초기 JavaScript 로드 및 실행 비용을
                    크게 줄여 TTI를 개선합니다.
                  </p>
                </div>
                <div class="border-t pt-6 border-border">
                  <h4 class="text-lg font-bold text-foreground">
                    3단계: Islands Architecture (섬 아키텍처)
                  </h4>
                  <p class="text-muted-foreground mt-2">
                    Partial Hydration을 더욱 발전시킨 개념으로,
                    <strong class="text-primary">Astro</strong>
                    프레임워크가 이를 적극적으로 채용했습니다. 페이지를 '정적인
                    HTML의 바다(Sea of Static HTML)'로 간주하고, 상호작용이
                    필요한 컴포넌트들을 '독립적인 섬(Island)'으로 취급합니다. 각
                    '섬'은 자신만의 JavaScript를 가지며, 서로에게 영향을 주지
                    않고 독립적으로 Hydration됩니다. 심지어 '사용자가 화면에서
                    볼 때', '버튼을 클릭했을 때' 등 특정 조건에서만 Hydration을
                    시작하도록 제어할 수도 있습니다.
                  </p>
                  <p class="text-sm mt-2 text-green-400">
                    <strong>개선점:</strong> 컴포넌트 단위의 정밀한 로딩 제어를
                    통해 웹 성능을 극한으로 최적화합니다. 콘텐츠 중심의
                    웹사이트(블로그, 마케팅 페이지 등)에 매우 효과적입니다.
                  </p>
                </div>
                <div class="border-t pt-6 border-border">
                  <h4 class="text-lg font-bold text-foreground">
                    4단계: 서버 컴포넌트 (Server Components)
                  </h4>
                  <p class="text-muted-foreground mt-2">
                    "애초에 상호작용이 필요 없는 컴포넌트의 JavaScript는 왜
                    클라이언트로 보내야 하는가?"라는 근본적인 질문에서
                    출발합니다.
                    <strong class="text-primary">React(Next.js)</strong>가
                    주도하는 이 패러다임은 컴포넌트를 두 종류로 나눕니다.
                  </p>
                  <ul
                    class="list-disc list-inside text-muted-foreground mt-2 space-y-1"
                  >
                    <li>
                      <strong>서버 컴포넌트:</strong> 서버에서만 렌더링되고, 그
                      결과물(HTML과 유사한 특수 포맷)만 클라이언트로 전송됩니다.
                      JavaScript 코드는 전혀 전송되지 않습니다. 데이터베이스
                      조회, 파일 시스템 접근 등 서버의 모든 능력을 활용할 수
                      있습니다.
                    </li>
                    <li>
                      <strong>클라이언트 컴포넌트:</strong> 기존의 방식처럼
                      클라이언트에서 Hydration되고 상호작용을 담당합니다. (예:
                      `onClick`, `useState` 사용)
                    </li>
                  </ul>
                  <p class="text-sm mt-2 text-blue-400">
                    <strong>핵심 아이디어:</strong> 기본적으로 모든 컴포넌트를
                    '제로-자바스크립트' 서버 컴포넌트로 만들고, 상호작용이 꼭
                    필요한 부분만 클라이언트 컴포넌트로 명시하여, 클라이언트에
                    전송되는 JS 양을 최소화합니다.
                  </p>
                  <div class="mt-6 flex flex-col items-center">
                    <img
                      src="images/sql_injection_sc.webp"
                      alt="sql_injection_sc"
                      class="border border-border rounded-md"
                    />
                    <span class="text-sm text-muted-foreground mt-2"
                      >뇌절의 SQL 인젝션</span
                    >
                  </div>
                </div>
                <p class="mt-6 p-4 bg-accent rounded-md border border-border">
                  <strong class="text-primary"
                    >백엔드 개발자에게 주는 시사점:</strong
                  >
                  이러한 렌더링 최적화는 프론트엔드만의 이슈가 아닙니다.
                  <strong>서버 컴포넌트</strong>나 Islands 아키텍처는 서버에서
                  더 많은 정보를 처리하고 정교하게 구조화된 HTML(또는 스트리밍
                  데이터)을 생성해야 합니다. 이는 프론트엔드와 백엔드(혹은
                  프론트엔드 서버) 간의 데이터 통신 방식과 API 설계에 영향을
                  미칩니다. 예를 들어, 서버 컴포넌트가 직접 데이터베이스에
                  접근하거나, 컴포넌트별로 독립적으로 데이터를 요청할 수 있도록
                  API를 세분화하는 전략 등을 함께 고민해야 합니다.
                </p>
              </div>
            </div>
          </section>

          <!-- Section: Trend 2 -->
          <section id="trend2" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              트렌드 2: DX(개발자 경험) 중심의 툴링 생태계
            </h2>
            <p class="text-muted-foreground mb-8">
              프론트엔드 개발의 복잡성이 증가함에 따라, 개발자의 생산성과
              만족도를 높이는 개발자 경험(DX)이 중요해졌습니다. 과거의 불편함을
              해결하고 개발 효율을 극대화하는 혁신적인 도구들이 등장하며
              생태계를 바꾸고 있습니다.
            </p>

            <!-- Sub-Section: Trend 2 - Build Tools -->
            <div id="trend2-build">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                🚀 빌드 도구의 진화: 기다림과의 싸움
              </h3>
              <p class="text-muted-foreground mb-8">
                더 빠른 빌드 속도는 개발 생산성 향상과 직결되며, 이는 백엔드
                개발자가 프론트엔드 빌드/배포를 기다리는 시간을 줄여 협업 효율을
                높이는 데도 기여합니다.
              </p>
              <div class="card p-6 rounded-md">
                <div
                  class="flex items-center justify-center space-x-4 mb-4 font-semibold text-center"
                >
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🐢</span>
                    <p class="text-sm">Webpack</p>
                    <p class="text-xs text-muted-foreground">느린 빌드</p>
                  </div>
                  <span class="text-2xl text-muted-foreground">→</span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🐇</span>
                    <p class="text-sm">Vite</p>
                    <p class="text-xs text-muted-foreground">빠른 개발 서버</p>
                  </div>
                  <span class="text-2xl text-muted-foreground">→</span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🚀</span>
                    <p class="text-sm">Turbopack</p>
                    <p class="text-xs text-muted-foreground">초고속 번들링</p>
                  </div>
                </div>
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong class="text-primary">Vite:</strong> ES 모듈(ESM)
                    기반의 개발 서버를 사용하여 웹팩(Webpack)보다 훨씬 빠르게
                    개발 서버를 시작하고 HMR(Hot Module Replacement)을
                    제공합니다. 개발 시 즉각적인 피드백을 제공하여 생산성을
                    높입니다.
                  </li>
                  <li>
                    <strong class="text-primary">Turbopack:</strong> Next.js의
                    새로운 Rust 기반 번들러로, Webpack보다 최대 700배, Vite보다
                    10배 빠른 빌드 속도를 목표로 합니다. 대규모 프로젝트에서
                    빌드 시간을 획기적으로 단축하여 개발자의 대기 시간을
                    줄여줍니다.
                  </li>
                </ul>
              </div>
            </div>

            <!-- Sub-Section: Trend 2 - Test Ecosystem -->
            <div id="trend2-test">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                🧪 프론트엔드 테스트 생태계
              </h3>
              <p class="text-muted-foreground mb-8">
                안정적인 애플리케이션은 백엔드 시스템의 부하를 줄이고, 예상치
                못한 프론트엔드 오류로 인한 사용자 불만을 최소화합니다.
              </p>
              <div class="card p-6 rounded-md">
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <span class="text-lg mr-2">✅</span
                    ><strong class="text-primary">Vitest:</strong> Vite 기반의
                    빠른 유닛/통합 테스트 프레임워크입니다. Jest와 유사한 API를
                    제공하여 기존 Jest 사용자들도 쉽게 전환할 수 있습니다.
                    컴포넌트의 작은 단위 로직을 빠르게 검증합니다.
                  </li>
                  <li>
                    <span class="text-lg mr-2">📚</span
                    ><strong class="text-primary">Storybook:</strong> UI
                    컴포넌트를 독립적으로 개발하고 문서화하며 테스트할 수 있는
                    환경을 제공합니다. 디자이너, QA, 다른 개발자와의 협업을 통해
                    컴포넌트의 일관성과 재사용성을 높입니다.
                  </li>
                  <li>
                    <span class="text-lg mr-2">🤖</span
                    ><strong class="text-primary">Playwright:</strong> 웹
                    애플리케이션의 엔드-투-엔드(E2E) 테스트를 위한 강력한
                    도구입니다. 실제 브라우저 환경에서 사용자 시나리오를
                    자동화하여 테스트하며, 브라우저 호환성 및 사용자 흐름의
                    안정성을 보장합니다.
                  </li>
                </ul>
              </div>
            </div>

            <!-- Sub-Section: Trend 2 - AI Tools -->
            <div id="trend2-ai">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                🤖 코드 제너레이션 도구 / AI 보조 도구
              </h3>
              <p class="text-muted-foreground mb-8">
                AI 도구는 개발자의 반복적인 작업을 줄여 더 창의적이고 복잡한
                문제 해결에 집중할 수 있도록 돕습니다. 이는 백엔드 개발자와의
                협업 시에도 더 고도화된 논의를 가능하게 합니다.
              </p>
              <div class="card p-6 rounded-md">
                <div
                  class="flex items-center justify-center space-x-4 mb-4 font-semibold text-center"
                >
                  <span class="text-5xl">✨</span>
                  <p class="text-lg">AI가 코드를 돕는다!</p>
                </div>
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong class="text-primary">코드 제너레이션 도구:</strong>
                    Next.js CLI와 같은 도구는 라우트, 컴포넌트, API 엔드포인트
                    등의 보일러플레이트 코드를 자동으로 생성하여 개발자가 핵심
                    로직에 집중할 수 있도록 돕습니다.
                  </li>
                  <li>
                    <strong class="text-primary"
                      >AI 보조 도구 (Copilot, Claude, AI 디자인툴 연동):</strong
                    >
                    <ul class="list-circle list-inside ml-4 text-sm">
                      <li>
                        <strong>GitHub Copilot:</strong> 개발자의 코딩 습관을
                        학습하여 코드 자동 완성, 함수 생성, 주석 기반 코드 작성
                        등을 지원합니다.
                      </li>
                      <li>
                        <strong>Claude/ChatGPT:</strong> 복잡한 로직의 코드
                        생성, 버그 디버깅, 문서화, 기술 스택 비교 등 개발 전반에
                        걸쳐 생산성을 향상시킵니다.
                      </li>
                      <li>
                        <strong>AI 디자인툴 연동 (예: Figma AI):</strong> 디자인
                        시안을 기반으로 코드 스니펫을 생성하거나, 디자인
                        시스템의 컴포넌트를 자동으로 코드화하여 디자이너와
                        개발자 간의 협업 간극을 줄여줍니다.
                      </li>
                    </ul>
                  </li>
                </ul>
              </div>
            </div>
          </section>

          <!-- Section: Trend 3 -->
          <section id="trend3" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              트렌드 3: UI/UX와 상태 관리의 패러다임 변화
            </h2>
            <p class="text-muted-foreground mb-8">
              애플리케이션의 상태 관리 패러다임이 '클라이언트' 중심에서 '서버'
              상태 중심으로 이동하고 있습니다. 이는 백엔드 API에서 받아온
              데이터를 프론트엔드에서 어떻게 다룰지에 대한 근본적인 변화를
              의미하며, API 설계에도 영향을 미칩니다.
            </p>

            <!-- Sub-Section: Trend 3 - State Paradigm -->
            <div id="trend3-state-paradigm">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                상태 관리 패러다임의 변화
              </h3>
              <p class="text-muted-foreground mb-8">
                과거에는 클라이언트에서 모든 상태를 관리했지만, 이제는 서버
                상태의 중요성이 부각되고 클라이언트 상태를 최소화하는 방향으로
                진화하고 있습니다.
              </p>
              <div class="card p-6 rounded-md mb-6">
                <div class="space-y-4">
                  <h4
                    class="text-lg font-semibold text-center text-foreground mb-6"
                  >
                    상태 관리 패러다임 변화 추이
                  </h4>

                  <!-- 2020년 -->
                  <div class="space-y-2">
                    <div class="flex justify-between items-center">
                      <span class="text-sm font-medium text-muted-foreground"
                        >2020년</span
                      >
                      <span class="text-sm text-muted-foreground"
                        >Redux/MobX 중심</span
                      >
                    </div>
                    <div class="w-full bg-muted rounded-full h-3">
                      <div
                        class="bg-red-400 h-3 rounded-full"
                        style="width: 85%"
                      ></div>
                    </div>
                    <div
                      class="flex justify-between text-xs text-muted-foreground"
                    >
                      <span>클라이언트 상태 관리</span>
                      <span>85%</span>
                    </div>
                  </div>

                  <!-- 2022년 -->
                  <div class="space-y-2">
                    <div class="flex justify-between items-center">
                      <span class="text-sm font-medium text-muted-foreground"
                        >2022년</span
                      >
                      <span class="text-sm text-muted-foreground"
                        >서버 상태 라이브러리 등장</span
                      >
                    </div>
                    <div class="w-full bg-muted rounded-full h-3">
                      <div
                        class="bg-blue-400 h-3 rounded-full"
                        style="width: 65%"
                      ></div>
                    </div>
                    <div
                      class="flex justify-between text-xs text-muted-foreground"
                    >
                      <span>TanStack Query/SWR</span>
                      <span>65%</span>
                    </div>
                  </div>

                  <!-- 2024년 -->
                  <div class="space-y-2">
                    <div class="flex justify-between items-center">
                      <span class="text-sm font-medium text-muted-foreground"
                        >2024년</span
                      >
                      <span class="text-sm text-muted-foreground"
                        >Server Components</span
                      >
                    </div>
                    <div class="w-full bg-muted rounded-full h-3">
                      <div
                        class="bg-green-400 h-3 rounded-full"
                        style="width: 45%"
                      ></div>
                    </div>
                    <div
                      class="flex justify-between text-xs text-muted-foreground"
                    >
                      <span>상태 최소화 접근</span>
                      <span>45%</span>
                    </div>
                  </div>

                  <!-- 2025년 예상 -->
                  <div class="space-y-2">
                    <div class="flex justify-between items-center">
                      <span class="text-sm font-medium text-primary"
                        >2025년 (예상)</span
                      >
                      <span class="text-sm text-primary">하이브리드 접근</span>
                    </div>
                    <div class="w-full bg-muted rounded-full h-3">
                      <div
                        class="bg-primary h-3 rounded-full"
                        style="width: 30%"
                      ></div>
                    </div>
                    <div
                      class="flex justify-between text-xs text-muted-foreground"
                    >
                      <span>최적화된 상태 관리</span>
                      <span>30%</span>
                    </div>
                  </div>
                </div>

                <p class="text-center mt-6 text-sm text-muted-foreground">
                  클라이언트에서 관리해야 하는 상태의 복잡도가 점점 감소하고
                  있습니다.
                </p>
                <p class="mt-4 text-muted-foreground">
                  과거에는 Redux, MobX처럼 클라이언트에서 모든 애플리케이션
                  상태(UI 상태, 데이터 상태 등)를 통합 관리하는 방식이 주를
                  이뤘습니다. 하지만 서버에서 가져온 데이터(서버 상태)는
                  클라이언트에서 관리하는 UI 상태와는 다른 특성(캐싱, 재검증,
                  동기화 필요)을 가집니다. 이에 따라 서버 상태 관리에 특화된
                  라이브러리들이 등장했고, Server Components와 같은 기술은 아예
                  클라이언트에서 관리해야 할 상태 자체를 최소화하는 방향으로
                  진화하고 있습니다. 이는 백엔드 API의 설계와 밀접한 관련이
                  있습니다.
                </p>
                <div
                  class="flex items-center justify-center space-x-4 mt-6 font-semibold text-center"
                >
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">📦</span>
                    <p class="text-sm">클라이언트 상태</p>
                    <p class="text-xs text-muted-foreground">Redux, MobX</p>
                  </div>
                  <span class="text-2xl text-muted-foreground">→</span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">☁️</span>
                    <p class="text-sm">서버 상태</p>
                    <p class="text-xs text-muted-foreground">TanStack Query</p>
                  </div>
                  <span class="text-2xl text-muted-foreground">→</span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">💡</span>
                    <p class="text-sm">상태 최소화</p>
                    <p class="text-xs text-muted-foreground">
                      Server Components
                    </p>
                  </div>
                </div>
              </div>
            </div>
            <!-- Sub-Section: Trend 3 - State Libraries -->
            <div id="trend3-state-libs">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                주요 상태 관리 라이브러리
              </h3>
              <p class="text-muted-foreground mb-8">
                다양한 상태 관리 라이브러리들이 각자의 강점을 가지고 프론트엔드
                개발에 활용되고 있습니다.
              </p>
              <div class="card p-6 rounded-md">
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong class="text-primary"
                      >TanStack Query (React Query):</strong
                    >
                    서버 상태 관리에 특화된 라이브러리로, 데이터 페칭, 캐싱,
                    동기화, 업데이트 등을 효율적으로 처리합니다. 백엔드 API와의
                    연동 시 매우 유용하며, 불필요한 API 호출을 줄이고 사용자
                    경험을 향상시킵니다.
                  </li>
                  <li>
                    <strong class="text-primary"
                      >Zustand / Jotai / Recoil:</strong
                    >
                    가볍고 유연한 클라이언트 상태 관리 라이브러리로, 전역 상태
                    관리를 간편하게 할 수 있도록 돕습니다. UI 관련 상태나
                    클라이언트에서만 필요한 상태 관리에 주로 사용됩니다.
                  </li>
                  <li>
                    <strong class="text-primary"
                      >Signal (Preact, SolidJS, Vue):</strong
                    >
                    세밀한 반응성(fine-grained reactivity)을 제공하여 상태 변경
                    시 필요한 컴포넌트만 정확히 업데이트하여 불필요한 렌더링을
                    줄이고 성능을 최적화하는 데 기여합니다. React에서도 Signal
                    개념의 도입이 논의되고 있습니다.
                  </li>
                </ul>
              </div>
            </div>
            <!-- Sub-Section: Trend 3 - Designer Collaboration -->
            <div id="trend3-design-collab">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                Tailwind + UI kit(shadcn-ui, Radix 등) → 디자이너와 협업 강화
              </h3>
              <p class="text-muted-foreground mb-8">
                디자인과 개발의 간극을 줄여 일관된 UI/UX를 제공하고,
                디자이너와의 협업을 강화하는 도구들이 주목받고 있습니다.
              </p>
              <div class="card p-6 rounded-md">
                <div
                  class="flex items-center justify-center space-x-4 mb-4 font-semibold text-center"
                >
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🎨</span>
                    <p class="text-sm">디자인</p>
                  </div>
                  <span class="text-2xl text-muted-foreground">↔️</span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">💻</span>
                    <p class="text-sm">개발</p>
                  </div>
                </div>
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong class="text-primary">Tailwind CSS:</strong>
                    유틸리티 우선(utility-first) CSS 프레임워크로, 미리 정의된
                    클래스들을 조합하여 스타일을 빠르게 적용할 수 있습니다. CSS
                    작성 시간을 줄이고 일관된 디자인을 유지하는 데 도움을
                    줍니다.
                  </li>
                  <li>
                    <strong class="text-primary"
                      >UI Kit (shadcn/ui, Radix UI):</strong
                    >
                    <ul class="list-circle list-inside ml-4 text-sm">
                      <li>
                        <strong>Radix UI:</strong> 접근성(Accessibility)과
                        커스터마이징에 중점을 둔 headless UI 컴포넌트
                        라이브러리입니다. 스타일은 포함되어 있지 않으며,
                        개발자가 직접 Tailwind 등으로 스타일을 입힙니다.
                      </li>
                      <li>
                        <strong>shadcn/ui:</strong> Radix UI를 기반으로 Tailwind
                        CSS를 사용하여 스타일링된 재사용 가능한 컴포넌트
                        모음입니다. 코드를 직접 프로젝트에 복사하여 수정할 수
                        있어 높은 유연성을 제공하며, 디자인 시스템 구축에 매우
                        효과적입니다.
                      </li>
                    </ul>
                  </li>
                </ul>
                <p class="mt-4 text-sm text-muted-foreground">
                  이러한 도구들은 디자인 시스템 구축을 용이하게 하고, 디자이너가
                  정의한 디자인 토큰과 컴포넌트를 개발자가 일관성 있게 구현할 수
                  있도록 도와 디자이너와의 협업을 강화합니다. 이는 백엔드
                  개발자가 API 설계 시 UI/UX 요구사항을 더 명확하게 이해하는 데
                  도움이 됩니다.
                </p>
              </div>
            </div>
          </section>

          <!-- Section: Trend 4 -->
          <section id="trend4" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              트렌드 4: 프론트엔드의 풀스택화
            </h2>
            <p class="text-muted-foreground mb-8">
              이제 프론트엔드는 클라이언트 코드뿐만 아니라 백엔드와의 효율적인
              연동을 위한 새로운 접근 방식이 등장하고 있습니다. 메타
              프레임워크가 제공하는 API Routes, Server Actions 등은 프론트엔드와
              백엔드의 경계를 허물고 있습니다. 이는 백엔드 개발 팀의 역할과
              책임에도 영향을 미칩니다.
            </p>

            <!-- Sub-Section: Trend 4 - Fullstack Tech -->
            <div id="trend4-fullstack-tech">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                프론트엔드 풀스택 기술
              </h3>
              <p class="text-muted-foreground mb-8">
                프론트엔드 개발자가 클라이언트 요구사항에 최적화된 데이터 처리
                및 백엔드 연동을 효율적으로 수행할 수 있게 하는 기술들이
                등장하고 있습니다.
              </p>
              <div class="card p-6 rounded-md mb-6">
                <div
                  class="grid grid-cols-1 md:grid-cols-3 gap-4 text-muted-foreground mb-6"
                >
                  <div class="border border-gray-200 p-4 rounded-md">
                    <h4 class="font-bold text-lg text-primary">
                      API Routes (Next.js)
                    </h4>
                    <p class="text-sm mt-2">
                      Next.js 프로젝트 내에서 백엔드 API 엔드포인트를 직접
                      정의할 수 있게 합니다. 간단한 데이터 처리, 외부 API 연동,
                      또는 민감한 API 키를 클라이언트에 노출하지 않고 사용하는
                      경우에 유용합니다. 이는 프론트엔드 개발자가 특정
                      클라이언트에 최적화된 BFF(Backend For Frontend) 계층을
                      직접 구축하는 것을 가능하게 합니다.
                    </p>
                  </div>
                  <div class="border border-gray-200 p-4 rounded-md">
                    <h4 class="font-bold text-lg text-primary">
                      Edge Functions (Vercel, Netlify, Cloudflare)
                    </h4>
                    <p class="text-sm mt-2">
                      CDN 엣지(Edge)에서 실행되는 서버리스 함수로, 사용자에게
                      가장 가까운 위치에서 코드를 실행하여 응답 시간을 단축하고
                      지연 시간을 줄입니다. A/B 테스트, 리다이렉션, 인증 처리,
                      지리 기반 콘텐츠 제공 등 백엔드 API 호출 전에 처리할 수
                      있는 경량 로직에 활용되어 백엔드 서버의 부하를 줄이고
                      사용자 경험을 향상시킵니다.
                    </p>
                  </div>
                  <div class="border border-gray-200 p-4 rounded-md">
                    <h4 class="font-bold text-lg text-primary">
                      Server Actions (Next.js)
                    </h4>
                    <p class="text-sm mt-2">
                      클라이언트 컴포넌트에서 서버 코드를 직접 호출할 수 있게
                      하는 혁신적인 기능입니다. API 엔드포인트를 별도로 정의할
                      필요 없이 폼 제출, 데이터베이스 업데이트 등 서버에서
                      실행되는 데이터 변경 로직을 클라이언트 코드와 더 긴밀하게
                      연결하여 개발의 복잡성을 줄이고, 클라이언트-서버 간의
                      데이터 흐름을 간소화합니다. 이는 기존 백엔드 API를
                      보완하고 프론트엔드 개발자가 클라이언트 요구사항에 맞는
                      특정 데이터 작업을 효율적으로 처리할 수 있도록 돕습니다.
                    </p>
                  </div>
                </div>
                <div
                  class="flex items-center justify-center space-x-4 font-semibold text-center"
                >
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🌐</span>
                    <p class="text-sm">클라이언트</p>
                  </div>
                  <span
                    class="text-2xl text-muted-foreground diagram-arrow"
                  ></span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">⚡️</span>
                    <p class="text-sm">Edge Function</p>
                    <p class="text-xs text-muted-foreground">(빠른 응답)</p>
                  </div>
                  <span
                    class="text-2xl text-muted-foreground diagram-arrow"
                  ></span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🖥️</span>
                    <p class="text-sm">FE 서버</p>
                    <p class="text-xs text-muted-foreground">
                      (SSR, API Routes)
                    </p>
                  </div>
                  <span
                    class="text-2xl text-muted-foreground diagram-arrow"
                  ></span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">☁️</span>
                    <p class="text-sm">BE 서버</p>
                    <p class="text-xs text-muted-foreground">(핵심 로직)</p>
                  </div>
                </div>
                <p class="mt-6 p-4 bg-accent rounded-md border border-border">
                  <strong class="text-primary"
                    >백엔드 개발자에게 주는 시사점:</strong
                  >
                  프론트엔드 팀이 클라이언트 특화된 데이터 처리 및 최적화를 위한
                  BFF(Backend For Frontend) 계층으로서의 역할을 강화하면서,
                  백엔드 팀은 더 복잡하고 핵심적인 비즈니스 로직 및 대규모
                  데이터 처리에 집중할 수 있습니다. 이러한 프론트엔드의 기능은
                  백엔드의 핵심 비즈니스 로직이나 복잡한 데이터 관리 시스템을
                  대체하는 것이 아니라, 기존 백엔드 시스템과의 효율적인 연동을
                  통해 전체 시스템의 성능과 개발 생산성을 향상시키는 데
                  기여합니다.
                </p>
              </div>
            </div>
            <!-- Sub-Section: Trend 4 - Cloud Integration -->
            <div id="trend4-cloud-integration">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                클라우드와 프론트엔드의 통합
              </h3>
              <p class="text-muted-foreground mb-8">
                Vercel, Netlify, Cloudflare와 같은 플랫폼들은 프론트엔드
                애플리케이션의 배포, 호스팅, CDN, 서버리스 함수(Edge Functions
                포함) 등을 통합하여 제공합니다.
              </p>
              <div class="card p-6 rounded-md">
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong>Vercel:</strong> Next.js 개발사에서 제공하는
                    플랫폼으로, Next.js 애플리케이션 배포에 최적화되어 있습니다.
                    Serverless Functions (API Routes, Edge Functions)를 쉽게
                    배포하고 관리할 수 있습니다.
                  </li>
                  <li>
                    <strong>Netlify:</strong> 정적 사이트 및 SPA 배포에 강점을
                    가지며, Netlify Functions를 통해 서버리스 백엔드 기능을
                    제공합니다. CI/CD 통합이 용이합니다.
                  </li>
                  <li>
                    <strong>Cloudflare:</strong> Workers를 통해 Edge에서
                    JavaScript 코드를 실행할 수 있는 강력한 서버리스 플랫폼을
                    제공합니다. CDN, 보안 기능과 통합되어 있습니다.
                  </li>
                </ul>
                <p class="mt-4">
                  <strong class="text-primary">시사점:</strong> 프론트엔드
                  개발자는 이제 인프라에 대한 깊은 지식 없이도 풀스택
                  애플리케이션을 쉽게 배포하고 관리할 수 있게 되었습니다. 이는
                  백엔드 개발 팀이 인프라 관리에 대한 부담을 덜고 핵심 서비스
                  개발에 집중할 수 있도록 돕습니다.
                </p>
              </div>
            </div>
          </section>

          <!-- Section: Trend 5 -->
          <section id="trend5" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              트렌드 5: 프론트엔드 개발자의 역할 확장
            </h2>
            <p class="text-muted-foreground mb-8">
              현대의 프론트엔드 개발자는 단순히 UI를 구현하는 것을 넘어, 제품의
              성공에 직접적으로 기여하는 다양한 역할을 수행합니다. 이는 제품의
              품질과 직결되며, 백엔드 개발자와의 협업 범위를 넓힙니다.
            </p>

            <!-- Sub-Section: Trend 5 - Roles Detail -->
            <div id="trend5-roles-detail">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                프론트엔드 개발자의 역할 확장 상세
              </h3>
              <p class="text-muted-foreground mb-8">
                프론트엔드 개발자의 역할은 단순히 UI를 구현하는 것을 넘어,
                제품의 성공에 직접적으로 기여하는 다양한 영역으로 확장되고
                있습니다.
              </p>
              <div
                class="grid grid-cols-2 md:grid-cols-3 lg:grid-cols-4 gap-4 text-center"
              >
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">🎨</span>
                  <p class="font-bold">UX (User Experience)</p>
                  <p class="text-xs text-muted-foreground">
                    사용자 흐름, 인터랙션 디자인, 사용성 테스트 등 사용자 경험
                    전반에 대한 이해와 개선 노력이 중요합니다. 백엔드 API 설계
                    시 사용자 시나리오를 함께 고려해야 합니다.
                  </p>
                </div>
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">⚡️</span>
                  <p class="font-bold">퍼포먼스 (Performance)</p>
                  <p class="text-xs text-muted-foreground">
                    웹 페이지 로딩 속도, 렌더링 성능, 번들 사이즈 최적화 등 성능
                    지표 개선을 위한 깊은 지식이 요구됩니다. 백엔드 API의 응답
                    속도와 데이터 용량은 프론트엔드 성능에 직접적인 영향을
                    미칩니다.
                  </p>
                </div>
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">🔍</span>
                  <p class="font-bold">SEO (Search Engine Optimization)</p>
                  <p class="text-xs text-muted-foreground">
                    검색 엔진 최적화를 위한 SSR/SSG 구현, 메타 태그 관리, 시맨틱
                    HTML 작성 등 백엔드와 협업하여 SEO를 고려해야 합니다. 특히
                    동적으로 변하는 콘텐츠의 SEO를 위해 백엔드와 프론트엔드의
                    긴밀한 협업이 필수적입니다.
                  </p>
                </div>
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">🛡️</span>
                  <p class="font-bold">보안 (Security)</p>
                  <p class="text-xs text-muted-foreground">
                    XSS, CSRF 등 웹 취약점에 대한 이해와 방어, 안전한 데이터
                    통신 구현 등 보안에 대한 책임이 커지고 있습니다. 백엔드와
                    함께 인증/인가 흐름, 데이터 암호화 등을 설계해야 합니다.
                  </p>
                </div>
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">♿️</span>
                  <p class="font-bold">접근성 (Accessibility)</p>
                  <p class="text-xs text-muted-foreground">
                    모든 사용자가 웹 콘텐츠에 동등하게 접근할 수 있도록 WCAG(Web
                    Content Accessibility Guidelines)를 준수하고, 시맨틱 HTML,
                    ARIA 속성 등을 활용합니다. 이는 백엔드에서 제공하는 데이터
                    구조와도 연관될 수 있습니다.
                  </p>
                </div>
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">📊</span>
                  <p class="font-bold">모니터링 (Monitoring)</p>
                  <p class="text-xs text-muted-foreground">
                    웹 성능, 에러 로깅, 사용자 행동 분석 등 프론트엔드
                    애플리케이션의 상태를 모니터링하고 개선하는 역할도
                    중요해지고 있습니다. 백엔드 로그 및 지표와 연동하여 전체
                    시스템의 건강 상태를 파악합니다.
                  </p>
                </div>
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">📈</span>
                  <p class="font-bold">데이터 시각화</p>
                  <p class="text-xs text-muted-foreground">
                    D3.js, Chart.js 등 라이브러리를 활용하여 복잡한 데이터를
                    직관적인 형태로 시각화하는 능력이 요구됩니다. 백엔드에서
                    시각화에 최적화된 형태로 데이터를 제공하는 것이 중요합니다.
                  </p>
                </div>
                <div
                  class="card p-4 rounded-md aspect-square flex flex-col justify-center items-center"
                >
                  <span class="text-4xl mb-2">🤖</span>
                  <p class="font-bold">AI UI 구현</p>
                  <p class="text-xs text-muted-foreground">
                    AI 모델과의 연동을 통해 실시간으로 데이터를 처리하고, AI가
                    생성한 콘텐츠를 사용자에게 보여주는 UI를 구현하는 역할도
                    늘어나고 있습니다. AI API와의 효율적인 통신 및 응답 처리
                    로직이 중요합니다.
                  </p>
                </div>
              </div>
            </div>
          </section>
          <!-- Section: Collaboration -->
          <section id="collaboration" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              백엔드 개발자를 위한 협업 가이드
            </h2>
            <p class="text-muted-foreground mb-8">
              프론트엔드 기술의 발전은 백엔드와의 협업 방식에 직접적인 영향을
              줍니다. 최신 협업 패턴을 이해하고 적용하면 개발 생산성과 안정성을
              크게 향상시킬 수 있습니다.
            </p>

            <!-- Sub-Section: Collaboration - Overview -->
            <div id="collaboration-overview">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                백엔드 협업 가이드: 협업 개요
              </h3>
              <p class="text-muted-foreground mb-8">
                프론트엔드 기술의 발전은 백엔드와의 협업 방식에 직접적인 영향을
                줍니다. 최신 협업 패턴을 이해하고 적용하면 개발 생산성과
                안정성을 크게 향상시킬 수 있습니다.
              </p>
              <div class="card p-6 rounded-md text-center mb-6">
                <p class="text-2xl font-bold text-primary mb-2">
                  "더 나은 제품을 위한 FE-BE 시너지"
                </p>
                <p class="">
                  효율적인 협업을 통해 개발 생산성을 높이고, 제품의 품질을
                  향상시킬 수 있습니다.
                </p>
              </div>
            </div>

            <!-- Sub-Section: Collaboration 1 -->
            <div id="collaboration1">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                백엔드 협업 가이드: 1. API 명세와 타입 공유
              </h3>
              <p class="text-muted-foreground mb-8">
                API 스펙을 정의하고 공유하는 방식이 진화하고 있습니다. 타입
                안전성(Type Safety)은 이제 선택이 아닌 필수입니다. 이는 백엔드와
                프론트엔드 간의 불필요한 소통 비용을 줄이고 개발 초기 단계에서
                오류를 방지하는 데 핵심적인 역할을 합니다.
              </p>
              <div class="card p-6 rounded-md">
                <h3 class="text-xl font-bold mb-4 text-foreground">
                  API 명세 및 타입 공유 흐름
                </h3>
                <div
                  class="flex items-center justify-center space-x-4 font-semibold text-center mb-6"
                >
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">📝</span>
                    <p class="text-sm">OpenAPI/Swagger</p>
                    <p class="text-xs text-muted-foreground">(API 명세)</p>
                  </div>
                  <span
                    class="text-2xl text-muted-foreground diagram-arrow"
                  ></span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🛡️</span>
                    <p class="text-sm">zod</p>
                    <p class="text-xs text-muted-foreground">(스키마 검증)</p>
                  </div>
                  <span
                    class="text-2xl text-muted-foreground diagram-arrow"
                  ></span>
                  <div class="flex flex-col items-center">
                    <span class="text-4xl">🔗</span>
                    <p class="text-sm">tRPC / ts-rest</p>
                    <p class="text-xs text-muted-foreground">
                      (타입 안전 통신)
                    </p>
                  </div>
                </div>
                <ul
                  class="list-disc list-inside text-muted-foreground space-y-2"
                >
                  <li>
                    <strong class="text-primary">OpenAPI/Swagger:</strong>
                    여전히 강력한 API 명세 도구이지만, 프론트엔드 개발 과정에서
                    API 스펙의 변경이 자주 발생할 수 있습니다. 명세의 최신화가
                    중요합니다.
                  </li>
                  <li>
                    <strong class="text-primary"
                      >zod 등 프론트 기반 검증:</strong
                    >
                    프론트엔드에서 `zod`와 같은 스키마 유효성 검사 라이브러리를
                    사용하여 API 응답 데이터의 유효성을 검증하는 경우가 늘고
                    있습니다. 이는 백엔드에서 제공하는 API 스펙과 프론트엔드에서
                    기대하는 데이터 형태 간의 불일치를 조기에 발견하는 데 도움이
                    됩니다.
                  </li>
                  <li>
                    <strong class="text-primary">ts-rest / tRPC:</strong>
                    <ul class="list-circle list-inside ml-4 text-sm">
                      <li>
                        <strong>ts-rest:</strong> REST API를 위한 타입 안전한
                        클라이언트/서버 통신 라이브러리로, 백엔드와 프론트엔드
                        간에 API 타입을 공유하여 개발 시 오류를 줄입니다.
                      </li>
                      <li>
                        <strong>tRPC:</strong> API 스키마 정의 없이 백엔드
                        함수를 직접 호출하는 것처럼 타입 안전한 통신을 가능하게
                        합니다. 이는 모노레포 환경에서 특히 강력한 이점을
                        제공하며, 백엔드와 프론트엔드 간의 타입 불일치 문제를
                        원천적으로 방지합니다.
                      </li>
                    </ul>
                  </li>
                </ul>
                <p class="mt-4 p-4 bg-accent rounded-md border border-border">
                  <strong class="text-primary">협업 제안:</strong> 백엔드에서
                  API 데이터의 요청 및 응답 타입을 TypeScript
                  인터페이스/타입으로 정의하고, 이를 프론트엔드와 공유하는
                  자동화된 프로세스(예: 코드 제너레이터 사용)를 구축하면 개발
                  생산성과 안정성을 크게 높일 수 있습니다. 이는 API 변경 시
                  발생할 수 있는 오류를 컴파일 타임에 잡을 수 있게 합니다.
                </p>
              </div>
            </div>
            <!-- Sub-Section: Collaboration 2 -->
            <div id="collaboration2">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                백엔드 협업 가이드: 2. BE ↔ FE 통신 구조의 모던화 및 렌더링
                방식 이해
              </h3>
              <p class="text-muted-foreground mb-8">
                프론트엔드가 페이지를 어떻게 그리는지(CSR vs SSR) 이해하면, 더
                효율적인 API를 설계하고 데이터 페칭 전략을 최적화할 수 있습니다.
                GraphQL과 React Suspense for Data Fetching과 같은 기술은 데이터
                통신 방식을 혁신하고 있습니다.
              </p>
              <div class="card p-6 rounded-md mb-6">
                <h3 class="text-xl font-bold mb-4 text-foreground">
                  CSR vs SSR: 렌더링 방식 비교
                </h3>
                <div class="flex justify-center mb-4">
                  <button
                    id="toggleRendering"
                    class="px-6 py-2 rounded-full bg-muted-foreground text-white font-semibold shadow-md transition"
                  >
                    CSR / SSR 전환
                  </button>
                </div>
                <div
                  id="csr-diagram"
                  class="border border-muted p-4 rounded-md text-muted-foreground"
                >
                  <h4 class="font-bold text-lg text-blue-800 mb-2">
                    CSR (Client Side Rendering) 흐름 🌐
                  </h4>
                  <div class="flex flex-col items-center space-y-2">
                    <div class="w-full card p-2 rounded-md">
                      브라우저: 빈 HTML + JS 파일 요청
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      서버: 빈 HTML, JS 파일 전송
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      브라우저: JS 실행 후 데이터 요청 (API 호출)
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      백엔드: JSON 데이터 응답
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      브라우저: 데이터 수신 후 화면 렌더링
                    </div>
                  </div>
                  <p class="text-xs mt-4 text-muted-foreground">
                    <strong>특징:</strong> 초기 로딩 후 빠른 인터랙션, SEO 불리,
                    백엔드는 주로 JSON 데이터 제공.
                  </p>
                </div>
                <div
                  id="ssr-diagram"
                  class="border border-green-200 bg-green-50 p-4 rounded-md text-muted-foreground hidden"
                >
                  <h4 class="font-bold text-lg text-green-800 mb-2">
                    SSR (Server Side Rendering) 흐름 🖥️
                  </h4>
                  <div class="flex flex-col items-center space-y-2">
                    <div class="w-full card p-2 rounded-md">
                      브라우저: 페이지 요청
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      프론트엔드 서버: 백엔드 API 호출 (데이터 요청)
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      백엔드: 데이터 응답
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      프론트엔드 서버: 데이터 채워진 완성 HTML 생성
                    </div>
                    <span class="text-2xl text-muted-foreground">⬇️</span>
                    <div class="w-full card p-2 rounded-md">
                      프론트엔드 서버: 완성 HTML 브라우저 전송
                    </div>
                  </div>
                  <p class="text-xs mt-4 text-muted-foreground">
                    <strong>특징:</strong> 초기 로딩 빠름, SEO 유리, 서버 부하
                    증가, 백엔드는 초기 렌더링에 필요한 데이터 제공.
                  </p>
                </div>
              </div>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-4">
                <div class="card p-6 rounded-md">
                  <h3 class="font-bold text-xl mb-3 text-foreground">
                    GraphQL
                  </h3>
                  <p class="text-muted-foreground">
                    클라이언트가 필요한 데이터를 정확히 요청할 수 있게 하여
                    오버페칭(Over-fetching: 필요 없는 데이터까지 가져오는
                    것)이나 언더페칭(Under-fetching: 필요한 데이터를 여러 번
                    요청하는 것) 문제를 해결합니다. 백엔드는 단일 GraphQL
                    엔드포인트를 제공하고, 프론트엔드는 필요한 쿼리를 작성하여
                    데이터를 가져옵니다. 이는 API의 유연성을 높이고 네트워크
                    효율성을 개선합니다.
                  </p>
                </div>
                <div class="card p-6 rounded-md">
                  <h3 class="font-bold text-xl mb-3 text-foreground">
                    Suspense for Data Fetching (React)
                  </h3>
                  <p class="text-muted-foreground">
                    React 18에서 도입된 기능으로, 데이터 페칭이 완료될 때까지
                    UI를 렌더링하지 않고 로딩 상태를 보여줄 수 있게 합니다. 이는
                    사용자 경험을 개선하고, 데이터 의존성 관리를 용이하게
                    합니다. 백엔드 API가 데이터를 얼마나 빠르게, 그리고 어떤
                    형태로 제공하는지가 Suspense의 효과를 극대화하는 데
                    중요합니다.
                  </p>
                </div>
              </div>
              <p class="mt-6 p-4 bg-accent rounded-md border border-border">
                <strong class="text-primary">협업 제안:</strong> 기존 REST API
                외에 GraphQL 도입을 고려하거나, Suspense와 같은 최신 프론트엔드
                데이터 페칭 패턴에 대한 이해를 통해 백엔드 API 설계 시
                프론트엔드 요구사항을 더 잘 반영할 수 있습니다. 예를 들어, N+1
                문제 해결을 위한 데이터 구조나, 여러 데이터를 한 번에 가져올 수
                있는 배치(batching) 기능 등을 고려할 수 있습니다.
              </p>
            </div>
            <!-- Sub-Section: Collaboration 3 -->
            <div id="collaboration3">
              <h3 class="text-xl font-bold mb-4 text-foreground">
                백엔드 협업 가이드: 3. 프론트엔드 성능 최적화 기법 이해
              </h3>
              <p class="text-muted-foreground mb-8">
                프론트엔드의 성능 최적화 기법들은 백엔드 API 설계 및 인프라
                전략과 밀접하게 연결되어 있습니다. 백엔드 개발자분들이 이러한
                개념을 이해하면 더욱 효율적인 시스템 아키텍처를 구축할 수
                있습니다.
              </p>
              <div class="grid grid-cols-1 md:grid-cols-2 gap-6">
                <div class="card p-6 rounded-md">
                  <h3 class="font-bold text-xl mb-3 text-foreground">
                    코드스플리팅 (Code Splitting)
                  </h3>
                  <div
                    class="flex items-center justify-center space-x-4 mb-4 font-semibold text-center"
                  >
                    <span class="text-4xl">📦</span>
                    <span class="text-2xl text-muted-foreground">→</span>
                    <span class="text-4xl">✂️</span>
                    <span class="text-2xl text-muted-foreground">→</span>
                    <span class="text-4xl">🧩</span>
                  </div>
                  <p class="text-muted-foreground">
                    애플리케이션의 JavaScript 코드를 여러 개의 작은 번들로
                    나누어 필요한 시점에만 로드하는 기법입니다. 초기 로딩 속도
                    개선에 필수적입니다. 사용자가 특정 기능이나 페이지에 진입할
                    때만 해당 코드 번들을 로드하여 전체 애플리케이션의 초기 로딩
                    부담을 줄입니다.
                  </p>
                  <p class="mt-2 text-sm text-muted-foreground">
                    <strong>백엔드 연관:</strong> 백엔드에서 제공하는 API
                    엔드포인트가 코드 스플리팅된 모듈에 따라 최적화될 수
                    있습니다. 예를 들어, 특정 기능에 필요한 데이터만 해당 코드
                    번들이 로드될 때 API를 호출하도록 설계할 수 있습니다.
                  </p>
                </div>
                <div class="card p-6 rounded-md">
                  <h3 class="font-bold text-xl mb-3 text-foreground">
                    캐싱 (Caching)
                  </h3>
                  <div
                    class="flex items-center justify-center space-x-4 mb-4 font-semibold text-center"
                  >
                    <span class="text-4xl">💾</span>
                    <span class="text-2xl text-muted-foreground">↔️</span>
                    <span class="text-4xl">🚀</span>
                  </div>
                  <p class="text-muted-foreground">
                    브라우저 캐시, CDN 캐시, 서버 캐시 등 다양한 레벨에서
                    데이터를 캐싱하여 성능을 최적화합니다. 자주 변경되지 않는
                    데이터를 캐시하여 불필요한 네트워크 요청을 줄이고 응답
                    시간을 단축합니다.
                  </p>
                  <p class="mt-2 text-sm text-muted-foreground">
                    <strong>백엔드 연관:</strong> 백엔드 API의 캐싱
                    헤더(Cache-Control, ETag, Last-Modified 등) 설정은
                    프론트엔드 캐싱 전략에 직접적인 영향을 미칩니다. 백엔드에서
                    캐싱 전략을 명확히 정의하고, 프론트엔드와 공유하여 일관된
                    캐싱 정책을 적용하는 것이 중요합니다.
                  </p>
                </div>
              </div>
              <p class="mt-6 p-4 bg-accent rounded-md border border-border">
                <strong class="text-primary">협업 제안:</strong> 백엔드
                개발자분들이 이러한 프론트엔드 최적화 기법들을 이해하고 있다면,
                API 응답 구조, 데이터 전송 방식, 캐싱 전략 등을 논의할 때 더욱
                효과적인 협업이 가능합니다. 예를 들어, SSR에 필요한 데이터를
                빠르게 제공하거나, 캐싱 전략을 백엔드와 프론트엔드가 함께
                논의하여 전체 시스템의 성능을 최적화할 수 있습니다.
              </p>
            </div>
          </section>

          <!-- Section: Conclusion -->
          <section id="conclusion" class="content-section pb-8">
            <h2 class="text-3xl font-bold mb-4 text-foreground">
              결론 - 프론트엔드, 함께 만드는 시대
            </h2>
            <p class="text-muted-foreground mb-8">
              이제 프론트엔드는 단순히 백엔드 API를 소비하는 역할에 머무르지
              않습니다. 자체적인 비즈니스 로직 처리, 데이터 관리, 서버리스 기능
              활용까지 백엔드 영역과의 경계가 허물어지면서, 제품 개발의 핵심적인
              축으로 자리 잡았습니다.
            </p>
            <div class="card p-8 rounded-md text-center">
              <p class="text-2xl font-bold text-primary mb-4">
                "프론트엔드는 더 이상 화면이 아닌,<br />백엔드의 가장 중요한
                '전략적 파트너'입니다."
              </p>
              <p class="">
                서로의 기술 스택과 아키텍처를 깊이 이해하고 긴밀하게 협력할 때,
                우리는 더 나은 제품을 더 빠르게 만들 수 있습니다. 프론트엔드와
                백엔드가 함께 시너지를 극대화하는 시대를 만들어 갑시다.
              </p>
            </div>
          </section>
        </div>
      </main>
    </div>

    <script>
      document.addEventListener('DOMContentLoaded', function () {
        const navLinks = document.querySelectorAll('.nav-link, .nav-sub-link');
        const contentSections = document.querySelectorAll('.content-section');
        let timelineItems = [];

        // List of section IDs that act only as headers
        const headerOnlySectionIds = [];

        function updateContent(hash) {
          let targetHash = hash;
          // Default to intro section if hash is empty or a header-only section
          if (
            !targetHash ||
            headerOnlySectionIds.includes(targetHash.substring(1))
          ) {
            targetHash = '#intro';
          }

          navLinks.forEach(link => {
            link.classList.remove('active');
          });

          const activeLink = document.querySelector(
            `.nav-link[href="${targetHash}"], .nav-sub-link[href="${targetHash}"]`
          );
          if (activeLink) {
            activeLink.classList.add('active');
            // Also activate the parent nav-link if a sub-link is active
            const parentLink = activeLink
              .closest('nav')
              .querySelector(
                `.nav-link[href^="#${targetHash.split('-')[0].substring(1)}"]`
              );
            if (parentLink && parentLink !== activeLink) {
              parentLink.classList.add('active');
            }
          }

          // Try to find the target element first
          const targetElement = document.getElementById(
            targetHash.substring(1)
          );

          if (targetElement) {
            // Check if target is a main section (.content-section)
            if (targetElement.classList.contains('content-section')) {
              // Hide all sections first
              const allContentSections =
                document.querySelectorAll('.content-section');
              allContentSections.forEach(section => {
                section.classList.remove('active', 'fade-in');
              });

              // Show the target section
              targetElement.classList.add('active', 'fade-in');

              // Scroll to top for main sections
              setTimeout(() => {
                // Find the main content area and scroll it to top
                const mainContent = document.querySelector(
                  'main.flex-1.overflow-y-auto'
                );
                if (mainContent) {
                  mainContent.scrollTo({
                    top: 0,
                    behavior: 'smooth',
                  });
                } else {
                  // Fallback to window scroll
                  window.scrollTo({
                    top: 0,
                    behavior: 'smooth',
                  });
                }
              }, 100);
            } else {
              // It's a subsection - find its parent section and show it
              const parentSection = targetElement.closest('.content-section');
              if (parentSection) {
                // Hide all sections first
                const allContentSections =
                  document.querySelectorAll('.content-section');
                allContentSections.forEach(section => {
                  section.classList.remove('active', 'fade-in');
                });

                // Show the parent section
                parentSection.classList.add('active', 'fade-in');

                // Wait for the parent section to be rendered, then scroll to subsection
                setTimeout(() => {
                  // Use scrollIntoView for subsections as fallback
                  targetElement.scrollIntoView({
                    behavior: 'smooth',
                    block: 'start',
                  });

                  // Then adjust with offset
                  setTimeout(() => {
                    window.scrollBy({
                      top: -20,
                      behavior: 'smooth',
                    });
                  }, 300);
                }, 200);
              }
            }
          }

          // Chart rendering logic - check if we need to render charts
          setTimeout(() => {
            if (
              targetHash === '#trend3-state-paradigm' ||
              targetHash === '#trend3'
            ) {
              renderStateManagementChart();
            } else {
              if (stateChart) {
                stateChart.destroy();
                stateChart = null;
              }
            }
          }, 500); // Increased delay to ensure DOM is ready

          // Timeline animation logic
          if (targetHash === '#intro-evolution') {
            startTimelineAnimation();
          } else {
            stopTimelineAnimation();
          }

          // Rendering toggle logic
          if (targetHash === '#collaboration2') {
            initRenderingToggle();
          }
        }

        function initTimeline() {
          timelineItems = document.querySelectorAll(
            '#timeline-container .timeline-item'
          );
          if (
            location.hash === '' ||
            location.hash === '#intro-evolution' ||
            location.hash === '#intro'
          ) {
            startTimelineAnimation();
          }
        }

        let timelineInterval;
        let currentTimelineIndex = 0;

        function animateTimeline() {
          timelineItems.forEach((item, index) => {
            item.classList.toggle('active', index === currentTimelineIndex);
          });
          currentTimelineIndex =
            (currentTimelineIndex + 1) % timelineItems.length;
        }

        function startTimelineAnimation() {
          if (timelineInterval) clearInterval(timelineInterval);
          currentTimelineIndex = 0;
          animateTimeline();
          timelineInterval = setInterval(animateTimeline, 3500); // Increased interval for better readability
        }

        function stopTimelineAnimation() {
          if (timelineInterval) clearInterval(timelineInterval);
          timelineInterval = null;
          timelineItems.forEach(item => item.classList.remove('active'));
        }

        function initRenderingToggle() {
          const toggleButton = document.getElementById('toggleRendering');
          const csrDiagram = document.getElementById('csr-diagram');
          const ssrDiagram = document.getElementById('ssr-diagram');
          let isCSR = true;

          if (!toggleButton || toggleButton.handlerAttached) return;

          toggleButton.onclick = () => {
            isCSR = !isCSR;
            if (isCSR) {
              csrDiagram.classList.remove('hidden');
              ssrDiagram.classList.add('hidden');
            } else {
              csrDiagram.classList.add('hidden');
              ssrDiagram.classList.remove('hidden');
            }
          };
          toggleButton.handlerAttached = true;
        }

        navLinks.forEach(link => {
          link.addEventListener('click', function (e) {
            e.preventDefault();
            let targetHash = this.getAttribute('href');

            if (headerOnlySectionIds.includes(targetHash.substring(1))) {
              const firstSubLink = document.querySelector(
                `.nav-sub-link[href^="${targetHash}-"]`
              );
              if (firstSubLink) {
                targetHash = firstSubLink.getAttribute('href');
              }
            }

            history.pushState(null, null, targetHash);
            updateContent(targetHash);
          });
        });

        window.addEventListener('popstate', () => {
          updateContent(location.hash);
        });

        initTimeline();
        updateContent(location.hash);
      });

      // Dark mode functionality
      function toggleDarkMode() {
        const html = document.documentElement;
        const darkModeIcon = document.querySelector('.dark-mode-icon');

        if (html.classList.contains('dark')) {
          html.classList.remove('dark');
          darkModeIcon.textContent = '◐';
          localStorage.setItem('darkMode', 'false');
        } else {
          html.classList.add('dark');
          darkModeIcon.textContent = '◑';
          localStorage.setItem('darkMode', 'true');
        }
      }

      // Initialize dark mode from localStorage
      document.addEventListener('DOMContentLoaded', function () {
        const darkModeStored = localStorage.getItem('darkMode');
        const darkModeIcon = document.querySelector('.dark-mode-icon');

        if (darkModeStored === 'true') {
          document.documentElement.classList.add('dark');
          darkModeIcon.textContent = '◑';
        } else {
          document.documentElement.classList.remove('dark');
          darkModeIcon.textContent = '◐';
        }
      });
    </script>
  </body>
</html>
